<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NU-6 Phoneme Scoring (Secure)</title>

    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>

    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- html2canvas for PNG Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <!-- Chart.js for Critical Difference Graph -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- jsPDF for Professional Reports -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>

    <!-- Tailwind CSS -->
    <script>
        // Load Tailwind CSS from the correct path (unpacked asar location in Electron)
        if (typeof require !== 'undefined') {
            const path = require('path');
            const fs = require('fs');
            let cssPath = path.join(__dirname, 'tailwind.min.css');
            // Check if we need to use the unpacked asar location
            if (__dirname.includes('app.asar')) {
                cssPath = path.join(__dirname.replace('app.asar', 'app.asar.unpacked'), 'tailwind.min.css');
            }
            try {
                const cssContent = fs.readFileSync(cssPath, 'utf-8');
                const style = document.createElement('style');
                style.textContent = cssContent;
                document.head.appendChild(style);
                console.log('Tailwind CSS injected successfully');
            } catch (error) {
                console.error('Failed to load Tailwind CSS:', error);
                // Fallback to link tag
                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = 'tailwind.min.css';
                document.head.appendChild(link);
            }
        } else {
            // Browser fallback
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = 'tailwind.min.css';
            document.head.appendChild(link);
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .phoneme-btn { transition: all 0.2s; }
        .ipa-text { font-family: 'Times New Roman', serif; }
        .tab-btn { transition: all 0.2s; }
        @media print {
            .no-print { display: none !important; }
            .print-only { display: block !important; }
            .page-break { page-break-before: always; }
        }
        /* Custom scrollbar for tables */
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f5f9; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
</head>
<body class="bg-slate-50 text-slate-900">
    <div id="root"></div>

    <!-- STANDARD JS: Cryptography & Database Logic -->
    <script>
        // --- CRYPTOGRAPHY SERVICE ---
        const CryptoService = {
            deriveKey: async (password, salt) => {
                const enc = new TextEncoder();
                const keyMaterial = await window.crypto.subtle.importKey(
                    "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]
                );
                return window.crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt: salt, iterations: 100000, hash: "SHA-256" },
                    keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]
                );
            },
            encryptData: async (dataObj, password) => {
                const salt = window.crypto.getRandomValues(new Uint8Array(16));
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const key = await CryptoService.deriveKey(password, salt);
                const enc = new TextEncoder();
                const encodedData = enc.encode(JSON.stringify(dataObj));
                const encryptedContent = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv }, key, encodedData
                );
                return {
                    salt: btoa(String.fromCharCode(...salt)),
                    iv: btoa(String.fromCharCode(...iv)),
                    data: btoa(String.fromCharCode(...new Uint8Array(encryptedContent)))
                };
            },
            decryptData: async (encryptedObj, password) => {
                try {
                    const salt = new Uint8Array(atob(encryptedObj.salt).split("").map(c => c.charCodeAt(0)));
                    const iv = new Uint8Array(atob(encryptedObj.iv).split("").map(c => c.charCodeAt(0)));
                    const data = new Uint8Array(atob(encryptedObj.data).split("").map(c => c.charCodeAt(0)));
                    const key = await CryptoService.deriveKey(password, salt);
                    const decryptedContent = await window.crypto.subtle.decrypt(
                        { name: "AES-GCM", iv: iv }, key, data
                    );
                    const dec = new TextDecoder();
                    return JSON.parse(dec.decode(decryptedContent));
                } catch (e) {
                    throw new Error("Decryption failed.");
                }
            }
        };

        // --- LOCAL INDEXEDDB CONFIGURATION ---
        const DB_NAME = 'NU6_Audiology_DB_Secure';
        const DB_VERSION = 1;
        const STORE_NAME = 'secure_tests';
        const CONFIG_STORE = 'app_config';

        const dbPromise = new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = (event) => {
                const error = event.target.error || event.target.errorCode || "Unknown database error";
                console.error("IndexedDB failed to open:", error);
                reject("Database error: " + error);
            };
            request.onsuccess = (event) => {
                console.log("IndexedDB opened successfully");
                resolve(event.target.result);
            };
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME, { keyPath: "id" });
                if (!db.objectStoreNames.contains(CONFIG_STORE)) db.createObjectStore(CONFIG_STORE, { keyPath: "id" });
            };
        });

        // --- SECURE DB INTERFACE ---
        window.SecureDB = {
            sessionPassword: null,
            isSetup: async () => {
                const db = await dbPromise;
                return new Promise((resolve) => {
                    const tx = db.transaction([CONFIG_STORE], "readonly");
                    const req = tx.objectStore(CONFIG_STORE).get("validation");
                    req.onsuccess = () => resolve(!!req.result);
                    req.onerror = () => resolve(false);
                });
            },
            setupPassword: async (password) => {
                const encryptedValidation = await CryptoService.encryptData({ check: "VALID" }, password);
                const db = await dbPromise;
                return new Promise((resolve, reject) => {
                    const tx = db.transaction([CONFIG_STORE], "readwrite");
                    tx.objectStore(CONFIG_STORE).put({ id: "validation", ...encryptedValidation });
                    tx.oncomplete = () => {
                        window.SecureDB.sessionPassword = password;
                        resolve(true);
                    };
                    tx.onerror = () => reject("Setup failed");
                });
            },
            login: async (password) => {
                const db = await dbPromise;
                return new Promise((resolve, reject) => {
                    const tx = db.transaction([CONFIG_STORE], "readonly");
                    const req = tx.objectStore(CONFIG_STORE).get("validation");
                    req.onsuccess = async () => {
                        if (!req.result) return reject("No setup found");
                        try {
                            const decrypted = await CryptoService.decryptData(req.result, password);
                            if (decrypted.check === "VALID") {
                                window.SecureDB.sessionPassword = password;
                                resolve(true);
                            } else {
                                resolve(false);
                            }
                        } catch (e) { resolve(false); }
                    };
                });
            },
            saveTest: async (data, options = {}) => {
                if (!window.SecureDB.sessionPassword) throw new Error("Database locked");
                const db = await dbPromise;

                // Normalize patient key for duplicate checks
                const patientKey = (data.cNumber || data.patientName || '').toString();
                const testDate = data.testDate || '';

                return new Promise((resolve, reject) => {
                    const tx = db.transaction([STORE_NAME], "readwrite");
                    const store = tx.objectStore(STORE_NAME);

                    // If caller provided an explicit id, treat as an update (overwrite)
                    if (data.id) {
                        (async () => {
                            try {
                                const encryptedData = await CryptoService.encryptData(data, window.SecureDB.sessionPassword);
                                store.put({ id: String(data.id), ...encryptedData });
                                tx.oncomplete = () => resolve(String(data.id));
                                tx.onerror = (e) => reject(e.target.error);
                            } catch (e) { reject(e); }
                        })();
                        return;
                    }

                    // No explicit id: check for same-patient + same-date duplicates
                    const getAllReq = store.getAll();
                    getAllReq.onsuccess = async () => {
                        try {
                            const raw = getAllReq.result || [];
                            // Decrypt records to inspect patient/testDate (skip records that fail to decrypt)
                            for (const rec of raw) {
                                try {
                                    const dec = await CryptoService.decryptData(rec, window.SecureDB.sessionPassword);
                                    const existingPatientKey = (dec.cNumber || dec.patientName || '').toString();
                                    const existingDate = dec.testDate || '';
                                    if (existingPatientKey === patientKey && existingDate === testDate) {
                                        // Found a same-patient same-date record
                                        if (options.overwriteExistingSameDate) {
                                            const encryptedData = await CryptoService.encryptData(data, window.SecureDB.sessionPassword);
                                            // overwrite using the existing record id
                                            store.put({ id: String(rec.id), ...encryptedData });
                                            tx.oncomplete = () => resolve(String(rec.id));
                                            tx.onerror = (e) => reject(e.target.error);
                                            return;
                                        } else {
                                            // Inform caller that a duplicate exists
                                            const err = new Error('A record for this patient on the same date already exists.');
                                            err.code = 'DUPLICATE_DATE';
                                            err.existingId = rec.id;
                                            reject(err);
                                            return;
                                        }
                                    }
                                } catch (e) {
                                    // ignore decrypt failures for individual records
                                }
                            }

                            // No duplicate found: create a new record id and save
                            try {
                                const encryptedData = await CryptoService.encryptData(data, window.SecureDB.sessionPassword);
                                const recordId = Date.now().toString();
                                store.put({ id: String(recordId), ...encryptedData });
                                tx.oncomplete = () => resolve(recordId);
                                tx.onerror = (e) => reject(e.target.error);
                            } catch (e) { reject(e); }
                        } catch (e) { reject(e); }
                    };

                    getAllReq.onerror = () => reject(getAllReq.error);
                });
            },
            getAllTests: async () => {
                if (!window.SecureDB.sessionPassword) throw new Error("Database locked");
                const db = await dbPromise;
                return new Promise((resolve, reject) => {
                    const tx = db.transaction([STORE_NAME], "readonly");
                    const req = tx.objectStore(STORE_NAME).getAll();
                    req.onsuccess = async () => {
                        try {
                            const rawRecords = req.result;
                            const decryptedRecords = await Promise.all(rawRecords.map(async (rec) => {
                                try {
                                    const dec = await CryptoService.decryptData(rec, window.SecureDB.sessionPassword);
                                    if(rec.id === 'clinic_settings') return { ...dec, id: 'clinic_settings', isSettings: true };
                                    return { ...dec, id: rec.id };
                                } catch (e) { return null; }
                            }));
                            const valid = decryptedRecords.filter(r => r !== null && !r.isSettings)
                                .sort((a, b) => new Date(b.testDate || 0) - new Date(a.testDate || 0));
                            resolve(valid);
                        } catch (e) { reject(e); }
                    };
                    req.onerror = () => reject(req.error);
                });
            },
            deleteTest: async (id) => {
                if (!window.SecureDB.sessionPassword) throw new Error("Database locked");
                const db = await dbPromise;
                return new Promise((resolve, reject) => {
                    const tx = db.transaction([STORE_NAME], "readwrite");
                    tx.objectStore(STORE_NAME).delete(id);
                    tx.oncomplete = () => resolve();
                    tx.onerror = (e) => reject(e.target.error);
                });
            },

            // Delete all tests (preserve clinic_settings)
            deleteAllTests: async () => {
                if (!window.SecureDB.sessionPassword) throw new Error("Database locked");
                const db = await dbPromise;
                return new Promise((resolve, reject) => {
                    const tx = db.transaction([STORE_NAME], "readwrite");
                    const store = tx.objectStore(STORE_NAME);
                    const req = store.getAllKeys();
                    req.onsuccess = () => {
                        const keys = req.result || [];
                        keys.forEach(k => {
                            if (k === 'clinic_settings') return;
                            store.delete(k);
                        });
                    };
                    tx.oncomplete = () => resolve();
                    tx.onerror = (e) => reject(e.target.error);
                });
            },

            saveSettings: async (settings) => {
                if (!window.SecureDB.sessionPassword) throw new Error("Database locked");
                const encryptedData = await CryptoService.encryptData(settings, window.SecureDB.sessionPassword);
                const db = await dbPromise;
                return new Promise((resolve, reject) => {
                    const tx = db.transaction([STORE_NAME], "readwrite");
                    tx.objectStore(STORE_NAME).put({ id: 'clinic_settings', ...encryptedData });
                    tx.oncomplete = () => resolve();
                    tx.onerror = (e) => reject(e.target.error);
                });
            },
            getSettings: async () => {
                if (!window.SecureDB.sessionPassword) throw new Error("Database locked");
                const db = await dbPromise;
                return new Promise((resolve, reject) => {
                    const tx = db.transaction([STORE_NAME], "readonly");
                    const req = tx.objectStore(STORE_NAME).get('clinic_settings');
                    req.onsuccess = async () => {
                        if (!req.result) return resolve(null);
                        try {
                            const dec = await CryptoService.decryptData(req.result, window.SecureDB.sessionPassword);
                            resolve(dec);
                        } catch (e) { resolve(null); }
                    };
                    req.onerror = () => reject(req.error);
                });
            },
            getPatientHistory: async (cNumber) => {
                const allTests = await window.SecureDB.getAllTests();
                const history = allTests.filter(t => t.cNumber && t.cNumber.toLowerCase() === cNumber.toLowerCase());
                // Sort chronologically: oldest dates first (left) → newest dates last (right)
                history.sort((a, b) => {
                    const da = a && a.testDate ? new Date(a.testDate) : new Date(0);
                    const db = b && b.testDate ? new Date(b.testDate) : new Date(0);
                    return da - db;
                });
                return history;
            }
        };
    </script>

    <!-- REACT APPLICATION -->
    <script type="text/babel">
        const { useState, useMemo, useEffect, useRef } = React;
        const { jsPDF } = window.jspdf;

        // --- INLINE ICONS ---
        const IconBase = ({ children, className, ...props }) => ( <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg> );
        const Calculator = (props) => ( <IconBase {...props}><rect width="16" height="20" x="4" y="2" rx="2" /><line x1="8" x2="16" y1="6" y2="6" /><line x1="16" x2="16" y1="14" y2="18" /><path d="M16 10h.01" /><path d="M12 10h.01" /><path d="M8 10h.01" /><path d="M12 14h.01" /><path d="M8 14h.01" /><path d="M12 18h.01" /><path d="M8 18h.01" /></IconBase> );
        const Save = (props) => ( <IconBase {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></IconBase> );
        const FolderOpen = (props) => ( <IconBase {...props}><path d="m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.55 6a2 2 0 0 1-1.94 1.5H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.93a2 2 0 0 1 1.66.9l.82 1.2a2 2 0 0 0 1.66.9H18a2 2 0 0 1 2 2v2"/></IconBase> );
        const Trash2 = (props) => ( <IconBase {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></IconBase> );
        const CheckCircle2 = (props) => ( <IconBase {...props}><circle cx="12" cy="12" r="10"/><path d="m9 12 2 2 4-4"/></IconBase> );
        const RotateCcw = (props) => ( <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconBase> );
        const Check = (props) => ( <IconBase {...props}><polyline points="20 6 9 17 4 12"/></IconBase> );
        const X = (props) => ( <IconBase {...props}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></IconBase> );
        const BarChart3 = (props) => ( <IconBase {...props}><path d="M3 3v18h18"/><path d="M18 17V9"/><path d="M13 17V5"/><path d="M8 17v-3"/></IconBase> );
        const ListChecks = (props) => ( <IconBase {...props}><path d="m3 17 2 2 4-4"/><path d="m3 7 2 2 4-4"/><path d="M13 6h8"/><path d="M13 12h8"/><path d="M13 18h8"/></IconBase> );
        const WholeWord = (props) => ( <IconBase {...props}><rect width="20" height="14" x="2" y="5" rx="2"/><path d="M2 10h20"/></IconBase> );
        const AlertCircle = (props) => ( <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></IconBase> );
        const HelpCircle = (props) => ( <IconBase {...props}><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></IconBase> );
        const Download = (props) => ( <IconBase {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></IconBase> );
        const TrendingUp = (props) => ( <IconBase {...props}><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/><polyline points="17 6 23 6 23 12"/></IconBase> );
        const Search = (props) => ( <IconBase {...props}><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></IconBase> );
        const Loader = (props) => ( <IconBase {...props} className="animate-spin"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></IconBase> );
        const Database = (props) => ( <IconBase {...props}><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></IconBase> );
        const FileUp = (props) => ( <IconBase {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 12v6"/><path d="m15 15-3-3-3 3"/></IconBase> );
        const HistoryIcon = (props) => ( <IconBase {...props}><path d="M3 3v5h5"/><path d="M3.05 13A9 9 0 1 0 6 5.3L3 8"/><path d="M12 7v5l4 2"/></IconBase> );
        const Activity = (props) => ( <IconBase {...props}><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></IconBase> );
        const Lock = (props) => ( <IconBase {...props}><rect x="3" y="11" width="18" height="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 10 0v4" /></IconBase> );
        const Flame = (props) => ( <IconBase {...props}><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.115.385-2.256 1.034-3.222l.173.239a5.32 5.32 0 0 0 2.293 2.483Z"/></IconBase> );
        const SettingsIcon = (props) => ( <IconBase {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconBase> );
        const FileText = (props) => ( <IconBase {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" x2="8" y1="13" y2="13"/><line x1="16" x2="8" y1="17" y2="17"/><line x1="10" x2="8" y1="9" y2="9"/></IconBase> );
        const Moon = (props) => ( <IconBase {...props}><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></IconBase> );
        const Sun = (props) => ( <IconBase {...props}><circle cx="12" cy="12" r="5"/><line x1="12" x2="12" y1="1" y2="3"/><line x1="12" x2="12" y1="21" y2="23"/><line x1="4.22" x2="5.64" y1="4.22" y2="5.64"/><line x1="18.36" x2="19.78" y1="18.36" y2="19.78"/><line x1="1" x2="3" y1="12" y2="12"/><line x1="21" x2="23" y1="12" y2="12"/><line x1="4.22" x2="5.64" y1="19.78" y2="18.36"/><line x1="18.36" x2="19.78" y1="5.64" y2="4.22"/></IconBase> );

        // ... [PHONEME_MAP, PHONEME_GROUPS, LISTS 1A-4A are the same] ...
        const PHONEME_MAP = { "f": "Fricative", "v": "Fricative", "θ": "Fricative", "ð": "Fricative", "s": "Fricative", "z": "Fricative", "ʃ": "Fricative", "ʒ": "Fricative", "h": "Fricative", "tʃ": "Affricate", "dʒ": "Affricate", "p": "Stop", "b": "Stop", "t": "Stop", "d": "Stop", "k": "Stop", "g": "Stop", "m": "Nasal", "n": "Nasal", "ŋ": "Nasal", "l": "Liquid/Glide", "r": "Liquid/Glide", "w": "Liquid/Glide", "j": "Liquid/Glide", "i": "Vowel", "ɪ": "Vowel", "eɪ": "Vowel", "ɛ": "Vowel", "æ": "Vowel", "u": "Vowel", "ʊ": "Vowel", "oʊ": "Vowel", "ɔ": "Vowel", "ɑ": "Vowel", "ʌ": "Vowel", "ɝ": "Vowel", "aɪ": "Vowel", "ɔɪ": "Vowel", "aʊ": "Vowel", "ə": "Vowel", "ɚ": "Vowel" };
        const PHONEME_GROUPS = { "High Frequency (Fricatives, Affricates, Stops)": ["Fricative", "Affricate", "Stop"], "Low Frequency (Nasals, Liquids, Glides, Vowels)": ["Nasal", "Liquid/Glide", "Vowel"] };
        
        // Phonetic features for manner, place, and voicing analysis
        const PHONEME_FEATURES = {
            // Stops
            "p": { manner: "Stop", place: "Bilabial", voicing: "Voiceless" },
            "b": { manner: "Stop", place: "Bilabial", voicing: "Voiced" },
            "t": { manner: "Stop", place: "Alveolar", voicing: "Voiceless" },
            "d": { manner: "Stop", place: "Alveolar", voicing: "Voiced" },
            "k": { manner: "Stop", place: "Velar", voicing: "Voiceless" },
            "g": { manner: "Stop", place: "Velar", voicing: "Voiced" },
            // Fricatives
            "f": { manner: "Fricative", place: "Labiodental", voicing: "Voiceless" },
            "v": { manner: "Fricative", place: "Labiodental", voicing: "Voiced" },
            "θ": { manner: "Fricative", place: "Dental", voicing: "Voiceless" },
            "ð": { manner: "Fricative", place: "Dental", voicing: "Voiced" },
            "s": { manner: "Fricative", place: "Alveolar", voicing: "Voiceless" },
            "z": { manner: "Fricative", place: "Alveolar", voicing: "Voiced" },
            "ʃ": { manner: "Fricative", place: "Postalveolar", voicing: "Voiceless" },
            "ʒ": { manner: "Fricative", place: "Postalveolar", voicing: "Voiced" },
            "h": { manner: "Fricative", place: "Glottal", voicing: "Voiceless" },
            // Affricates
            "tʃ": { manner: "Affricate", place: "Postalveolar", voicing: "Voiceless" },
            "dʒ": { manner: "Affricate", place: "Postalveolar", voicing: "Voiced" },
            // Nasals
            "m": { manner: "Nasal", place: "Bilabial", voicing: "Voiced" },
            "n": { manner: "Nasal", place: "Alveolar", voicing: "Voiced" },
            "ŋ": { manner: "Nasal", place: "Velar", voicing: "Voiced" },
            // Liquids and Glides
            "l": { manner: "Liquid", place: "Alveolar", voicing: "Voiced" },
            "r": { manner: "Liquid", place: "Postalveolar", voicing: "Voiced" },
            "w": { manner: "Glide", place: "Bilabial-Velar", voicing: "Voiced" },
            "j": { manner: "Glide", place: "Palatal", voicing: "Voiced" },
            // Vowels (all voiced, varying places)
            "i": { manner: "Vowel", place: "High-Front", voicing: "Voiced" },
            "ɪ": { manner: "Vowel", place: "High-Front", voicing: "Voiced" },
            "eɪ": { manner: "Vowel", place: "Mid-Front", voicing: "Voiced" },
            "ɛ": { manner: "Vowel", place: "Mid-Front", voicing: "Voiced" },
            "æ": { manner: "Vowel", place: "Low-Front", voicing: "Voiced" },
            "u": { manner: "Vowel", place: "High-Back", voicing: "Voiced" },
            "ʊ": { manner: "Vowel", place: "High-Back", voicing: "Voiced" },
            "oʊ": { manner: "Vowel", place: "Mid-Back", voicing: "Voiced" },
            "ɔ": { manner: "Vowel", place: "Mid-Back", voicing: "Voiced" },
            "ɑ": { manner: "Vowel", place: "Low-Back", voicing: "Voiced" },
            "ʌ": { manner: "Vowel", place: "Mid-Central", voicing: "Voiced" },
            "ɝ": { manner: "Vowel", place: "Mid-Central", voicing: "Voiced" },
            "aɪ": { manner: "Vowel", place: "Low-Front", voicing: "Voiced" },
            "ɔɪ": { manner: "Vowel", place: "Mid-Back", voicing: "Voiced" },
            "aʊ": { manner: "Vowel", place: "Low-Back", voicing: "Voiced" },
            "ə": { manner: "Vowel", place: "Mid-Central", voicing: "Voiced" },
            "ɚ": { manner: "Vowel", place: "Mid-Central", voicing: "Voiced" }
        };
        const LIST_1A = [ { i: 1, w: "LAUD", p: ["l", "ɔ", "d"] }, { i: 2, w: "BOAT", p: ["b", "oʊ", "t"] }, { i: 3, w: "POOL", p: ["p", "u", "l"] }, { i: 4, w: "NAG", p: ["n", "æ", "g"] }, { i: 5, w: "LIMB", p: ["l", "ɪ", "m"] }, { i: 6, w: "SHOUT", p: ["ʃ", "aʊ", "t"] }, { i: 7, w: "SUB", p: ["s", "ʌ", "b"] }, { i: 8, w: "VINE", p: ["v", "aɪ", "n"] }, { i: 9, w: "DIME", p: ["d", "aɪ", "m"] }, { i: 10, w: "GOOSE", p: ["g", "u", "s"] }, { i: 11, w: "WHIP", p: ["w", "ɪ", "p"] }, { i: 12, w: "TOUGH", p: ["t", "ʌ", "f"] }, { i: 13, w: "PUFF", p: ["p", "ʌ", "f"] }, { i: 14, w: "KEEN", p: ["k", "i", "n"] }, { i: 15, w: "DEATH", p: ["d", "ɛ", "θ"] }, { i: 16, w: "SELL", p: ["s", "ɛ", "l"] }, { i: 17, w: "TAKE", p: ["t", "eɪ", "k"] }, { i: 18, w: "FALL", p: ["f", "ɔ", "l"] }, { i: 19, w: "RAISE", p: ["r", "eɪ", "z"] }, { i: 20, w: "THIRD", p: ["θ", "ɝ", "d"] }, { i: 21, w: "GAP", p: ["g", "æ", "p"] }, { i: 22, w: "FAT", p: ["f", "æ", "t"] }, { i: 23, w: "MET", p: ["m", "ɛ", "t"] }, { i: 24, w: "JAR", p: ["dʒ", "ɑ", "r"] }, { i: 25, w: "DOOR", p: ["d", "ɔ", "r"] }, { i: 26, w: "LOVE", p: ["l", "ʌ", "v"] }, { i: 27, w: "SURE", p: ["ʃ", "ʊ", "r"] }, { i: 28, w: "KNOCK", p: ["n", "ɑ", "k"] }, { i: 29, w: "CHOICE", p: ["tʃ", "ɔɪ", "s"] }, { i: 30, w: "HASH", p: ["h", "æ", "ʃ"] }, { i: 31, w: "LOT", p: ["l", "ɑ", "t"] }, { i: 32, w: "RAID", p: ["r", "eɪ", "d"] }, { i: 33, w: "HURL", p: ["h", "ɝ", "l"] }, { i: 34, w: "MOON", p: ["m", "u", "n"] }, { i: 35, w: "PAGE", p: ["p", "eɪ", "dʒ"] }, { i: 36, w: "YES", p: ["j", "ɛ", "s"] }, { i: 37, w: "REACH", p: ["r", "i", "tʃ"] }, { i: 38, w: "KING", p: ["k", "ɪ", "ŋ"] }, { i: 39, w: "HOME", p: ["h", "oʊ", "m"] }, { i: 40, w: "RAG", p: ["r", "æ", "g"] }, { i: 41, w: "WHICH", p: ["w", "ɪ", "tʃ"] }, { i: 42, w: "WEEK", p: ["w", "i", "k"] }, { i: 43, w: "SIZE", p: ["s", "aɪ", "z"] }, { i: 44, w: "MODE", p: ["m", "oʊ", "d"] }, { i: 45, w: "BEAN", p: ["b", "i", "n"] }, { i: 46, w: "TIP", p: ["t", "ɪ", "p"] }, { i: 47, w: "CHALK", p: ["tʃ", "ɔ", "k"] }, { i: 48, w: "JAIL", p: ["dʒ", "eɪ", "l"] }, { i: 49, w: "BURN", p: ["b", "ɝ", "n"] }, { i: 50, w: "KITE", p: ["k", "aɪ", "t"] } ];
        const LIST_2A = [ { i: 1, w: "PICK", p: ["p", "ɪ", "k"] }, { i: 2, w: "ROOM", p: ["r", "u", "m"] }, { i: 3, w: "NICE", p: ["n", "aɪ", "s"] }, { i: 4, w: "SAID", p: ["s", "ɛ", "d"] }, { i: 5, w: "FAIL", p: ["f", "eɪ", "l"] }, { i: 6, w: "SOUTH", p: ["s", "aʊ", "θ"] }, { i: 7, w: "WHITE", p: ["w", "aɪ", "t"] }, { i: 8, w: "KEEP", p: ["k", "i", "p"] }, { i: 9, w: "DEAD", p: ["d", "ɛ", "d"] }, { i: 10, w: "LOAF", p: ["l", "oʊ", "f"] }, { i: 11, w: "DAB", p: ["d", "æ", "b"] }, { i: 12, w: "NUMB", p: ["n", "ʌ", "m"] }, { i: 13, w: "JUICE", p: ["dʒ", "u", "s"] }, { i: 14, w: "CHIEF", p: ["tʃ", "i", "f"] }, { i: 15, w: "MERGE", p: ["m", "ɝ", "dʒ"] }, { i: 16, w: "WAG", p: ["w", "æ", "g"] }, { i: 17, w: "RAIN", p: ["r", "eɪ", "n"] }, { i: 18, w: "WITCH", p: ["w", "ɪ", "tʃ"] }, { i: 19, w: "SOAP", p: ["s", "oʊ", "p"] }, { i: 20, w: "YOUNG", p: ["j", "ʌ", "ŋ"] }, { i: 21, w: "TON", p: ["t", "ʌ", "n"] }, { i: 22, w: "KEG", p: ["k", "ɛ", "g"] }, { i: 23, w: "CALM", p: ["k", "ɑ", "m"] }, { i: 24, w: "TOOL", p: ["t", "u", "l"] }, { i: 25, w: "PIKE", p: ["p", "aɪ", "k"] }, { i: 26, w: "MILL", p: ["m", "ɪ", "l"] }, { i: 27, w: "HUSH", p: ["h", "ʌ", "ʃ"] }, { i: 28, w: "SHACK", p: ["ʃ", "æ", "k"] }, { i: 29, w: "READ", p: ["r", "i", "d"] }, { i: 30, w: "ROT", p: ["r", "ɑ", "t"] }, { i: 31, w: "HATE", p: ["h", "eɪ", "t"] }, { i: 32, w: "LIVE", p: ["l", "ɪ", "v"] }, { i: 33, w: "BOOK", p: ["b", "ʊ", "k"] }, { i: 34, w: "VOICE", p: ["v", "ɔɪ", "s"] }, { i: 35, w: "GAZE", p: ["g", "eɪ", "z"] }, { i: 36, w: "PAD", p: ["p", "æ", "d"] }, { i: 37, w: "THOUGHT", p: ["θ", "ɔ", "t"] }, { i: 38, w: "BOUGHT", p: ["b", "ɔ", "t"] }, { i: 39, w: "TURN", p: ["t", "ɝ", "n"] }, { i: 40, w: "CHAIR", p: ["tʃ", "ɛ", "r"] }, { i: 41, w: "LORE", p: ["l", "ɔ", "r"] }, { i: 42, w: "BITE", p: ["b", "aɪ", "t"] }, { i: 43, w: "HAZE", p: ["h", "eɪ", "z"] }, { i: 44, w: "MATCH", p: ["m", "æ", "tʃ"] }, { i: 45, w: "LEARN", p: ["l", "ɝ", "n"] }, { i: 46, w: "SHAWL", p: ["ʃ", "ɔ", "l"] }, { i: 47, w: "DEEP", p: ["d", "i", "p"] }, { i: 48, w: "GIN", p: ["dʒ", "ɪ", "n"] }, { i: 49, w: "GOAL", p: ["g", "oʊ", "l"] }, { i: 50, w: "FAR", p: ["f", "ɑ", "r"] } ];
        const LIST_3A = [ { i: 1, w: "BASE", p: ["b", "eɪ", "s"] }, { i: 2, w: "MESS", p: ["m", "ɛ", "s"] }, { i: 3, w: "CAUSE", p: ["k", "ɔ", "z"] }, { i: 4, w: "MOP", p: ["m", "ɑ", "p"] }, { i: 5, w: "GOOD", p: ["g", "ʊ", "d"] }, { i: 6, w: "LUCK", p: ["l", "ʌ", "k"] }, { i: 7, w: "WALK", p: ["w", "ɔ", "k"] }, { i: 8, w: "YOUTH", p: ["j", "u", "θ"] }, { i: 9, w: "PAIN", p: ["p", "eɪ", "n"] }, { i: 10, w: "DATE", p: ["d", "eɪ", "t"] }, { i: 11, w: "PEARL", p: ["p", "ɝ", "l"] }, { i: 12, w: "SEARCH", p: ["s", "ɝ", "tʃ"] }, { i: 13, w: "DITCH", p: ["d", "ɪ", "tʃ"] }, { i: 14, w: "TALK", p: ["t", "ɔ", "k"] }, { i: 15, w: "RING", p: ["r", "ɪ", "ŋ"] }, { i: 16, w: "GERM", p: ["dʒ", "ɝ", "m"] }, { i: 17, w: "LIFE", p: ["l", "aɪ", "f"] }, { i: 18, w: "TEAM", p: ["t", "i", "m"] }, { i: 19, w: "LID", p: ["l", "ɪ", "d"] }, { i: 20, w: "POLE", p: ["p", "oʊ", "l"] }, { i: 21, w: "RODE", p: ["r", "oʊ", "d"] }, { i: 22, w: "SHALL", p: ["ʃ", "æ", "l"] }, { i: 23, w: "LATE", p: ["l", "eɪ", "t"] }, { i: 24, w: "CHEEK", p: ["tʃ", "i", "k"] }, { i: 25, w: "BEG", p: ["b", "ɛ", "g"] }, { i: 26, w: "GUN", p: ["g", "ʌ", "n"] }, { i: 27, w: "JUG", p: ["dʒ", "ʌ", "g"] }, { i: 28, w: "SHEEP", p: ["ʃ", "i", "p"] }, { i: 29, w: "FIVE", p: ["f", "aɪ", "v"] }, { i: 30, w: "RUSH", p: ["r", "ʌ", "ʃ"] }, { i: 31, w: "RAT", p: ["r", "æ", "t"] }, { i: 32, w: "VOID", p: ["v", "ɔɪ", "d"] }, { i: 33, w: "WIRE", p: ["w", "aɪ", "r"] }, { i: 34, w: "HALF", p: ["h", "æ", "f"] }, { i: 35, w: "NOTE", p: ["n", "oʊ", "t"] }, { i: 36, w: "WHEN", p: ["w", "ɛ", "n"] }, { i: 37, w: "NAME", p: ["n", "eɪ", "m"] }, { i: 38, w: "THIN", p: ["θ", "ɪ", "n"] }, { i: 39, w: "TELL", p: ["t", "ɛ", "l"] }, { i: 40, w: "BAR", p: ["b", "ɑ", "r"] }, { i: 41, w: "MOUSE", p: ["m", "aʊ", "s"] }, { i: 42, w: "HIRE", p: ["h", "aɪ", "r"] }, { i: 43, w: "CAB", p: ["k", "æ", "b"] }, { i: 44, w: "HIT", p: ["h", "ɪ", "t"] }, { i: 45, w: "CHAT", p: ["tʃ", "æ", "t"] }, { i: 46, w: "PHONE", p: ["f", "oʊ", "n"] }, { i: 47, w: "SOUP", p: ["s", "u", "p"] }, { i: 48, w: "DODGE", p: ["d", "ɑ", "dʒ"] }, { i: 49, w: "SEIZE", p: ["s", "i", "z"] }, { i: 50, w: "COOL", p: ["k", "u", "l"] } ];
        const LIST_4A = [ { i: 1, w: "PASS", p: ["p", "æ", "s"] }, { i: 2, w: "DOLL", p: ["d", "ɑ", "l"] }, { i: 3, w: "BACK", p: ["b", "æ", "k"] }, { i: 4, w: "RED", p: ["r", "ɛ", "d"] }, { i: 5, w: "WASH", p: ["w", "ɔ", "ʃ"] }, { i: 6, w: "SOUR", p: ["s", "aʊ", "r"] }, { i: 7, w: "BONE", p: ["b", "oʊ", "n"] }, { i: 8, w: "GET", p: ["g", "ɛ", "t"] }, { i: 9, w: "WHEAT", p: ["w", "i", "t"] }, { i: 10, w: "THUMB", p: ["θ", "ʌ", "m"] }, { i: 11, w: "SALE", p: ["s", "eɪ", "l"] }, { i: 12, w: "YEARN", p: ["j", "ɝ", "n"] }, { i: 13, w: "WIFE", p: ["w", "aɪ", "f"] }, { i: 14, w: "SUCH", p: ["s", "ʌ", "tʃ"] }, { i: 15, w: "NEAT", p: ["n", "i", "t"] }, { i: 16, w: "PEG", p: ["p", "ɛ", "g"] }, { i: 17, w: "MOB", p: ["m", "ɑ", "b"] }, { i: 18, w: "GAS", p: ["g", "æ", "s"] }, { i: 19, w: "CHECK", p: ["tʃ", "ɛ", "k"] }, { i: 20, w: "JOIN", p: ["dʒ", "ɔɪ", "n"] }, { i: 21, w: "LEASE", p: ["l", "i", "s"] }, { i: 22, w: "LONG", p: ["l", "ɔ", "ŋ"] }, { i: 23, w: "CHAIN", p: ["tʃ", "eɪ", "n"] }, { i: 24, w: "KILL", p: ["k", "ɪ", "l"] }, { i: 25, w: "HOLE", p: ["h", "oʊ", "l"] }, { i: 26, w: "LEAN", p: ["l", "i", "n"] }, { i: 27, w: "TAPE", p: ["t", "eɪ", "p"] }, { i: 28, w: "TIRE", p: ["t", "aɪ", "r"] }, { i: 29, w: "DIP", p: ["d", "ɪ", "p"] }, { i: 30, w: "ROSE", p: ["r", "oʊ", "z"] }, { i: 31, w: "CAME", p: ["k", "eɪ", "m"] }, { i: 32, w: "FIT", p: ["f", "ɪ", "t"] }, { i: 33, w: "MAKE", p: ["m", "eɪ", "k"] }, { i: 34, w: "VOTE", p: ["v", "oʊ", "t"] }, { i: 35, w: "JUDGE", p: ["dʒ", "ʌ", "dʒ"] }, { i: 36, w: "FOOD", p: ["f", "u", "d"] }, { i: 37, w: "RIPE", p: ["r", "aɪ", "p"] }, { i: 38, w: "HAVE", p: ["h", "æ", "v"] }, { i: 39, w: "ROUGH", p: ["r", "ʌ", "f"] }, { i: 40, w: "KICK", p: ["k", "ɪ", "k"] }, { i: 41, w: "LOSE", p: ["l", "u", "z"] }, { i: 42, w: "NEAR", p: ["n", "i", "r"] }, { i: 43, w: "PERCH", p: ["p", "ɝ", "tʃ"] }, { i: 44, w: "SHIRT", p: ["ʃ", "ɝ", "t"] }, { i: 45, w: "BATH", p: ["b", "æ", "θ"] }, { i: 46, w: "TIME", p: ["t", "aɪ", "m"] }, { i: 47, w: "HALL", p: ["h", "ɔ", "l"] }, { i: 48, w: "MOOD", p: ["m", "u", "d"] }, { i: 49, w: "DOG", p: ["d", "ɔ", "g"] }, { i: 50, w: "SHOULD", p: ["ʃ", "ʊ", "d"] } ];
        const LIST_HF1 = [ { i: 1, w: "CHECK", p: ["tʃ", "ɛ", "k"] }, { i: 2, w: "PUSH", p: ["p", "ʊ", "ʃ"] }, { i: 3, w: "VOICE", p: ["v", "ɔɪ", "s"] }, { i: 4, w: "SIT", p: ["s", "ɪ", "t"] }, { i: 5, w: "THUMB", p: ["θ", "ʌ", "m"] }, { i: 6, w: "SHAPE", p: ["ʃ", "eɪ", "p"] }, { i: 7, w: "YOUTH", p: ["j", "u", "θ"] }, { i: 8, w: "FACE", p: ["f", "eɪ", "s"] }, { i: 9, w: "GAS", p: ["g", "æ", "s"] }, { i: 10, w: "TEACH", p: ["t", "i", "tʃ"] }, { i: 11, w: "SAFE", p: ["s", "eɪ", "f"] }, { i: 12, w: "HISS", p: ["h", "ɪ", "s"] }, { i: 13, w: "BUS", p: ["b", "ʌ", "s"] }, { i: 14, w: "CHIEF", p: ["tʃ", "i", "f"] }, { i: 15, w: "PATH", p: ["p", "æ", "θ"] }, { i: 16, w: "VOTE", p: ["v", "oʊ", "t"] }, { i: 17, w: "RICH", p: ["r", "ɪ", "tʃ"] }, { i: 18, w: "CATCH", p: ["k", "æ", "tʃ"] }, { i: 19, w: "KEEP", p: ["k", "i", "p"] }, { i: 20, w: "FISH", p: ["f", "ɪ", "ʃ"] }, { i: 21, w: "SOUTH", p: ["s", "aʊ", "θ"] }, { i: 22, w: "CHOOSE", p: ["tʃ", "u", "z"] }, { i: 23, w: "TIP", p: ["t", "ɪ", "p"] }, { i: 24, w: "SHAKE", p: ["ʃ", "eɪ", "k"] }, { i: 25, w: "NOISE", p: ["n", "ɔɪ", "z"] } ];

        const LIST_HF2 = [ { i: 1, w: "TOUCH", p: ["t", "ʌ", "tʃ"] }, { i: 2, w: "LIFE", p: ["l", "aɪ", "f"] }, { i: 3, w: "FIT", p: ["f", "ɪ", "t"] }, { i: 4, w: "SUM", p: ["s", "ʌ", "m"] }, { i: 5, w: "SHOES", p: ["ʃ", "u", "z"] }, { i: 6, w: "NECK", p: ["n", "ɛ", "k"] }, { i: 7, w: "MOUTH", p: ["m", "aʊ", "θ"] }, { i: 8, w: "DEEP", p: ["d", "i", "p"] }, { i: 9, w: "PASS", p: ["p", "æ", "s"] }, { i: 10, w: "CHOICE", p: ["tʃ", "ɔɪ", "s"] }, { i: 11, w: "NOTE", p: ["n", "oʊ", "t"] }, { i: 12, w: "BATH", p: ["b", "æ", "θ"] }, { i: 13, w: "SHIP", p: ["ʃ", "ɪ", "p"] }, { i: 14, w: "KISS", p: ["k", "ɪ", "s"] }, { i: 15, w: "REACH", p: ["r", "i", "tʃ"] }, { i: 16, w: "FUSS", p: ["f", "ʌ", "s"] }, { i: 17, w: "BEEF", p: ["b", "i", "f"] }, { i: 18, w: "CASE", p: ["k", "eɪ", "s"] }, { i: 19, w: "WISH", p: ["w", "ɪ", "ʃ"] }, { i: 20, w: "DIP", p: ["d", "ɪ", "p"] }, { i: 21, w: "TAKE", p: ["t", "eɪ", "k"] }, { i: 22, w: "SIZE", p: ["s", "aɪ", "z"] }, { i: 23, w: "MATCH", p: ["m", "æ", "tʃ"] }, { i: 24, w: "TOOTH", p: ["t", "u", "θ"] }, { i: 25, w: "BUSH", p: ["b", "ʊ", "ʃ"] } ];

        // --- PAIRWISE MONTE CARLO WORD TABLES (N=10,25,50 | 80%,95%) ---

        // --- Simulated DB for quick import/testing (generated 100 longitudinal records) ---
        const SIMULATED_DB = (() => {
            const records = [];
            const firstNames = ['Alex','Chris','Sam','Taylor','Jordan','Morgan','Casey','Jamie','Riley','Avery','Dakota','Peyton','Quinn','Cameron','Robin','Skyler','Reese','Rowan','Elliot','Blake'];
            const lastNames = ['Johnson','Smith','Brown','Lee','Garcia','Martinez','Davis','Miller','Wilson','Moore','Taylor','Anderson','Thomas','Jackson','White','Harris','Martin','Thompson','Young','King'];
            let seed = 123456;
            const rand = () => { seed = (seed * 9301 + 49297) % 233280; return seed / 233280; };
            const randInt = (min, max) => Math.floor(rand() * (max - min + 1)) + min;
            const lists = ['1A','2A','3A','4A'];
            const NUM_RECORDS = 100;
            const PATIENTS = 20; // approximate number of unique patients for longitudinal data

            // Track last date per patient so repeated records are clustered (more longitudinal)
            const patientLastDaysAgo = new Array(PATIENTS).fill(null);
            const patientBaselinePercent = new Array(PATIENTS).fill(null); // baseline word % per patient (phoneme ~20% lower)
            const patientPrevModeA = new Array(PATIENTS).fill(null);
            const patientPrevModeB = new Array(PATIENTS).fill(null);

            for (let i = 0; i < NUM_RECORDS; i++) {
                // Bias patient selection so some patients have more longitudinal records
                let patientIndex;
                if (rand() < 0.7) {
                    // more repeats in a smaller subgroup
                    const subgroup = Math.max(3, Math.floor(PATIENTS / 3));
                    patientIndex = randInt(0, subgroup - 1);
                } else {
                    patientIndex = randInt(0, PATIENTS - 1);
                }

                const patientName = `${firstNames[patientIndex % firstNames.length]} ${lastNames[patientIndex % lastNames.length]}`;
                const cNumber = `SIM-${String(patientIndex + 1).padStart(3, '0')}`;

                // Cluster dates for the same patient so longitudinal records are near each other
                let daysAgo;
                if (patientLastDaysAgo[patientIndex] === null) {
                    daysAgo = randInt(0, 365);
                } else {
                    daysAgo = Math.max(0, Math.min(365, patientLastDaysAgo[patientIndex] + randInt(-30, 30)));
                }
                patientLastDaysAgo[patientIndex] = daysAgo;
                const testDate = new Date(Date.now() - daysAgo * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

                // Establish or reuse a patient baseline to keep longitudinal results orderly
                if (patientBaselinePercent[patientIndex] === null) {
                    // Baselines concentrated in a mid-range (less variance overall)
                    patientBaselinePercent[patientIndex] = randInt(45, 75);
                } else {
                    // small drift over time to avoid cyclic extremes
                    patientBaselinePercent[patientIndex] = Math.max(10, Math.min(95, patientBaselinePercent[patientIndex] + randInt(-2, 2)));
                }
                const baseline = patientBaselinePercent[patientIndex];

                // Randomize scoringMode per test but bias to keep mode same across longitudinal tests
                let scoringModeA = (patientPrevModeA[patientIndex] && rand() < 0.7) ? patientPrevModeA[patientIndex] : (rand() < 0.5 ? 'phoneme' : 'word');
                let scoringModeB = (patientPrevModeB[patientIndex] && rand() < 0.7) ? patientPrevModeB[patientIndex] : (rand() < 0.5 ? 'phoneme' : 'word');

                // Enforce phoneme parity: if either test is phoneme-scored, make both phoneme-scored
                if (scoringModeA === 'phoneme' || scoringModeB === 'phoneme') {
                    scoringModeA = scoringModeB = 'phoneme';
                }

                patientPrevModeA[patientIndex] = scoringModeA;
                patientPrevModeB[patientIndex] = scoringModeB;

                const listA = lists[randInt(0, lists.length - 1)];
                const listB = lists[randInt(0, lists.length - 1)];

                // Enforce condition constraints:
                // Test A must be one of ['Unaided', 'Current Tech']
                // Test B must be one of ['Current Tech', 'New Tech']
                const condAOptions = ['Unaided', 'Current Tech'];
                const condBOptions = ['Current Tech', 'New Tech'];
                let condA = condAOptions[randInt(0, condAOptions.length - 1)];
                let condB = condBOptions[randInt(0, condBOptions.length - 1)];
                // Avoid both being 'Current Tech' — prefer making Test B 'New Tech' if conflict
                if (condA === condB) {
                    condB = 'New Tech';
                }

                // Shared level and noise (SNR) between A and B
                const level = `${randInt(50,80)} dB`;
                const SNR_OPTIONS = [5, 10, 15];
                const snrValue = `${SNR_OPTIONS[randInt(0, SNR_OPTIONS.length - 1)]} dB SNR`;

                // Lightweight in-generator stats calcuator (word% / phoneme%) so we can enforce relationships
                const computeStatsLocal = (listId, section, scores, limitTo10 = false) => {
                    const allWords = listId === '1A' ? LIST_1A : listId === '2A' ? LIST_2A : listId === '3A' ? LIST_3A : LIST_4A;
                    let visibleWords = allWords;
                    if (section === 'first') visibleWords = allWords.slice(0, 25);
                    else if (section === 'first_10') visibleWords = allWords.slice(0, 10);
                    else if (section === 'second') visibleWords = allWords.slice(25, 50);
                    else if (section === 'second_10') visibleWords = allWords.slice(25, 35);
                    else if (section === 'full') visibleWords = allWords;
                    if (limitTo10) visibleWords = visibleWords.slice(0, 10);
                    let totalPhonemes = 0; let correctPhonemes = 0; let correctWords = 0; let totalWords = visibleWords.length;
                    visibleWords.forEach(word => {
                        let wordCorrectCount = 0; let wordPhonemeCount = 0;
                        word.p.forEach((phoneme, pIndex) => {
                            if (phoneme === '-') return;
                            wordPhonemeCount++; totalPhonemes++;
                            const key = `${listId}_${word.i}_${pIndex}`;
                            if (scores[key]) { correctPhonemes++; wordCorrectCount++; }
                        });
                        if (wordCorrectCount === wordPhonemeCount && wordPhonemeCount > 0) { correctWords++; }
                    });
                    return {
                        totalPhonemes, correctPhonemes, phonemePercent: totalPhonemes === 0 ? 0 : Math.round((correctPhonemes / totalPhonemes) * 100),
                        correctWords, totalWords, wordPercent: totalWords === 0 ? 0 : Math.round((correctWords / totalWords) * 100)
                    };
                };

                // Helper to generate realistic score maps used by calculateStats()
                // Accept a percentBase representing the approximate WORD % for the test (phoneme will be ~20% lower)
                const genScoresFor = (listId, section, scoringMode, limitTo10, percentBase) => {
                    const allWords = listId === '1A' ? LIST_1A : listId === '2A' ? LIST_2A : listId === '3A' ? LIST_3A : LIST_4A;
                    let visibleWords = allWords;
                    if (section === 'first') visibleWords = allWords.slice(0, 25);
                    else if (section === 'first_10') visibleWords = allWords.slice(0, 10);
                    else if (section === 'second') visibleWords = allWords.slice(25, 50);
                    else if (section === 'second_10') visibleWords = allWords.slice(25, 35);
                    else if (section === 'full') visibleWords = allWords;
                    if (limitTo10) visibleWords = visibleWords.slice(0, 10);

                    const scores = {};

                    if (scoringMode === 'word') {
                        // Use provided percentBase with small perturbation for per-test noise
                        let percent = percentBase + randInt(-3, 3);
                        percent = Math.max(0, Math.min(100, percent));
                        const correctWords = Math.round(visibleWords.length * (percent / 100));
                        const chosen = new Set();
                        while (chosen.size < correctWords && chosen.size < visibleWords.length) {
                            chosen.add(randInt(0, visibleWords.length - 1));
                        }
                        chosen.forEach(idx => {
                            const w = visibleWords[idx];
                            w.p.forEach((ph, pIdx) => { if (ph !== '-') scores[`${listId}_${w.i}_${pIdx}`] = true; });
                        });
                    } else {
                        // Phoneme scoring: roughly 20% lower than word base with small perturbation
                        const phonemeKeys = [];
                        visibleWords.forEach(w => w.p.forEach((ph, pIdx) => { if (ph !== '-') phonemeKeys.push(`${listId}_${w.i}_${pIdx}`); }));
                        if (phonemeKeys.length > 0) {
                            let percent = (percentBase - 20) + randInt(-3, 3);
                            percent = Math.max(0, Math.min(100, percent));
                            const correctCount = Math.round(phonemeKeys.length * (percent / 100));
                            const chosen = new Set();
                            while (chosen.size < correctCount && chosen.size < phonemeKeys.length) {
                                chosen.add(phonemeKeys[randInt(0, phonemeKeys.length - 1)]);
                            }
                            chosen.forEach(k => scores[k] = true);
                        }
                    }

                    // Ensure there is at least one scored item
                    if (Object.keys(scores).length === 0) {
                        // Force one phoneme correct
                        const fallbackWord = visibleWords[0];
                        if (fallbackWord && fallbackWord.p) {
                            for (let pIdx = 0; pIdx < fallbackWord.p.length; pIdx++) {
                                if (fallbackWord.p[pIdx] !== '-') { scores[`${listId}_${fallbackWord.i}_${pIdx}`] = true; break; }
                            }
                        }
                    }

                    return scores;
                };

                const limitA = rand() < 0.25;
                const limitB = rand() < 0.25;

                // Create condition-aware percent baselines so New Tech >= Current Tech >= Unaided (usually)
                const unaidedBase = Math.max(0, Math.min(100, baseline + randInt(-5, 5)));
                const currentBase = Math.max(0, Math.min(100, unaidedBase + randInt(0, 7)));
                const newBase = Math.max(0, Math.min(100, Math.max(currentBase, unaidedBase) + randInt(0, 7)));

                const percentBaseA = condA === 'Unaided' ? unaidedBase : (condA === 'Current Tech' ? currentBase : newBase);
                const percentBaseB = condB === 'Unaided' ? unaidedBase : (condB === 'Current Tech' ? currentBase : newBase);

                // Slight per-test generation then validate and adjust if needed
                let scoresA = genScoresFor(listA, 'second_10', scoringModeA, limitA, percentBaseA);
                let scoresB = genScoresFor(listB, 'second_10', scoringModeB, limitB, percentBaseB);

                // Compute quick stats to validate ordering constraints
                let statsA = computeStatsLocal(listA, 'second_10', scoresA, limitA);
                let statsB = computeStatsLocal(listB, 'second_10', scoresB, limitB);

                // Enforce that Current Tech / New Tech are almost always better than Unaided
                // Small chance of exception to keep data realistic
                const TECH_EXCEPTION_CHANCE = 0.05;
                const ensureTechBetterThanUnaided = (techListId, techScores, techStats, techLimit, techScoringMode, techPercentBase, unaidedStats) => {
                    if (rand() < TECH_EXCEPTION_CHANCE) return { techStats, techScores };
                    let attempts = 0;
                    while (techStats.wordPercent + 2 < unaidedStats.wordPercent && attempts < 6) {
                        attempts++;
                        const boost = 2 + randInt(0, 6);
                        const boostedBase = Math.min(100, Math.max(techPercentBase, unaidedStats.wordPercent + boost));
                        techScores = genScoresFor(techListId, 'second_10', techScoringMode, techLimit, boostedBase);
                        techStats = computeStatsLocal(techListId, 'second_10', techScores, techLimit);
                    }
                    return { techStats, techScores };
                };

                if (condA === 'Unaided' && (condB === 'Current Tech' || condB === 'New Tech')) {
                    const r = ensureTechBetterThanUnaided(listB, scoresB, statsB, limitB, scoringModeB, percentBaseB, statsA);
                    statsB = r.techStats; scoresB = r.techScores;
                } else if (condB === 'Unaided' && (condA === 'Current Tech' || condA === 'New Tech')) {
                    const r = ensureTechBetterThanUnaided(listA, scoresA, statsA, limitA, scoringModeA, percentBaseA, statsB);
                    statsA = r.techStats; scoresA = r.techScores;
                }

                // If New Tech should generally be equal or better than other conditions, enforce it
                if (condB === 'New Tech') {
                    // If B is much worse (word% at least 10 points lower), try regenerating B a few times with boosted base
                    let attempts = 0;
                    while (statsB.wordPercent + 10 < statsA.wordPercent && attempts < 6) {
                        attempts++;
                        // bump the base so New Tech improves relative to A
                        const boost = Math.max(5, Math.round((statsA.wordPercent - statsB.wordPercent) / 2));
                        const newBase = Math.min(100, Math.max(percentBaseB, percentBaseA + boost + randInt(0, 4)));
                        scoresB = genScoresFor(listB, 'second_10', scoringModeB, limitB, newBase);
                        statsB = computeStatsLocal(listB, 'second_10', scoresB, limitB);
                    }
                }

                // If scoring modes cause extreme inversion (phoneme>word or huge swings), make small adjustments
                if (statsA.wordPercent < statsA.phonemePercent) {
                    // try to nudge A by regenerating with slightly higher base
                    const newBaseA = Math.min(100, percentBaseA + 5);
                    scoresA = genScoresFor(listA, 'second_10', scoringModeA, limitA, newBaseA);
                    statsA = computeStatsLocal(listA, 'second_10', scoresA, limitA);
                }
                if (statsB.wordPercent < statsB.phonemePercent) {
                    const newBaseB = Math.min(100, percentBaseB + 5);
                    scoresB = genScoresFor(listB, 'second_10', scoringModeB, limitB, newBaseB);
                    statsB = computeStatsLocal(listB, 'second_10', scoresB, limitB);
                }

                // Ensure phoneme presence mirrored between Test A and Test B
                const hasPhonemeA = Object.keys(scoresA).length > 0;
                const hasPhonemeB = Object.keys(scoresB).length > 0;
                if (hasPhonemeA && !hasPhonemeB) {
                    // regenerate B as phoneme-scored so both have phoneme-level entries
                    scoresB = genScoresFor(listB, 'second_10', 'phoneme', limitB, percentBaseB);
                    statsB = computeStatsLocal(listB, 'second_10', scoresB, limitB);
                } else if (hasPhonemeB && !hasPhonemeA) {
                    scoresA = genScoresFor(listA, 'second_10', 'phoneme', limitA, percentBaseA);
                    statsA = computeStatsLocal(listA, 'second_10', scoresA, limitA);
                }

                // Set comparativeEase based on observed word performance (scaled and clamped 0-10)
                let comparativeEase = Math.round((statsB.wordPercent - statsA.wordPercent) / 10) + 5;
                if (comparativeEase < 0) comparativeEase = 0; if (comparativeEase > 10) comparativeEase = 10;

                records.push({
                    id: `sim-${String(i + 1).padStart(3, '0')}`,
                    patientName,
                    cNumber,
                    testDate,
                    notes: `Simulated record ${i + 1} for ${patientName}`,
                    activeTestId: rand() < 0.5 ? 'A' : 'B',
                    activeTab: rand() < 0.5 ? 'comparison' : 'scoring',
                    confidenceLevel: rand() < 0.5 ? 95 : 80,
                    tests: {
                        A: { id: 'A', listId: listA, section: 'second_10', scoringMode: scoringModeA, condition: condA, deviceModel: rand() < 0.3 ? `Model-${randInt(1,5)}` : '', level: level, snr: snrValue, scores: scoresA, limitTo10: limitA, askedContinue: false },
                        B: { id: 'B', listId: listB, section: 'second_10', scoringMode: scoringModeB, condition: condB, deviceModel: rand() < 0.3 ? `Model-${randInt(1,5)}` : '', level: level, snr: snrValue, scores: scoresB, limitTo10: limitB, askedContinue: false },
                        comparativeEase: comparativeEase
                    }
                });
            }
            return records;
        })();
        // Load critical difference tables from CSV
        const loadCriticalDifferenceTables = async (confidenceLevel) => {
            const fileName = `${confidenceLevel}_Word_Recognition_Critical_Differences_Simulated_v2.csv`;
            try {
                let csvText;
                // Check if we're in Electron (packaged app)
                if (typeof require !== 'undefined') {
                    const fs = require('fs');
                    const path = require('path');
                    // In packaged Electron apps, check both regular path and unpacked path
                    let filePath = path.join(__dirname, fileName);
                    if (!fs.existsSync(filePath)) {
                        // Try the unpacked asar location
                        filePath = path.join(__dirname.replace('app.asar', 'app.asar.unpacked'), fileName);
                    }
                    console.log('Loading CSV from:', filePath);
                    csvText = fs.readFileSync(filePath, 'utf-8');
                } else {
                    // Browser/dev environment
                    const response = await fetch(fileName);
                    csvText = await response.text();
                }
                
                // Parse CSV
                const lines = csvText.trim().split('\n');
                const headers = lines[0].split(',');
                
                // Build table structure
                const tables = {};
                
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    const scenario = values[0]; // e.g., "WW_10", "WW_25", "WW_50", "Phoneme_10", etc.
                    const scorePercent = parseFloat(values[5]); // Score_Percent column
                    const lowerLimit = parseFloat(values[6]); // Lower_Limit_Percent column
                    const upperLimit = parseFloat(values[7]); // Upper_Limit_Percent column
                    
                    // Skip phoneme scenarios - only process word scenarios
                    if (scenario.startsWith('Phoneme_')) continue;
                    
                    // Extract N from scenario (e.g., "WW_10" -> "10")
                    const nValue = scenario.split('_')[1];
                    
                    if (!tables[nValue]) {
                        tables[nValue] = {};
                    }
                    
                    // Store with score as key
                    tables[nValue][scorePercent.toFixed(1)] = [lowerLimit, upperLimit];
                }
                
                return tables;
            } catch (error) {
                console.error('Error loading critical difference tables:', error);
                // Return empty structure if loading fails
                return { "10": {}, "25": {}, "50": {} };
            }
        };

        // Load phoneme critical difference tables from CSV
        const loadPhonemeTables = async (confidenceLevel) => {
            const fileName = `${confidenceLevel}_Word_Recognition_Critical_Differences_Simulated_v2.csv`;
            try {
                let csvText;
                // Check if we're in Electron (packaged app)
                if (typeof require !== 'undefined') {
                    const fs = require('fs');
                    const path = require('path');
                    // In packaged Electron apps, check both regular path and unpacked path
                    let filePath = path.join(__dirname, fileName);
                    if (!fs.existsSync(filePath)) {
                        // Try the unpacked asar location
                        filePath = path.join(__dirname.replace('app.asar', 'app.asar.unpacked'), fileName);
                    }
                    console.log('Loading CSV from:', filePath);
                    csvText = fs.readFileSync(filePath, 'utf-8');
                } else {
                    // Browser/dev environment
                    const response = await fetch(fileName);
                    csvText = await response.text();
                }
                
                // Parse CSV
                const lines = csvText.trim().split('\n');
                const tables = {};
                
                // Mapping: Phoneme_10 -> 30, Phoneme_25 -> 75, Phoneme_50 -> 150
                const scenarioToTableKey = {
                    'Phoneme_10': '30',
                    'Phoneme_25': '75',
                    'Phoneme_50': '150'
                };
                
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    const scenario = values[0];
                    const scorePercent = parseFloat(values[5]);
                    const lowerLimit = parseFloat(values[6]);
                    const upperLimit = parseFloat(values[7]);
                    
                    // Only process phoneme scenarios
                    if (!scenario.startsWith('Phoneme_')) continue;
                    
                    // Map scenario to table key
                    const tableKey = scenarioToTableKey[scenario];
                    if (!tableKey) continue;
                    
                    if (!tables[tableKey]) {
                        tables[tableKey] = {};
                    }
                    
                    // Store with score as key
                    tables[tableKey][scorePercent.toFixed(1)] = [lowerLimit, upperLimit];
                }
                
                return tables;
            } catch (error) {
                console.error('Error loading phoneme tables:', error);
                // Return empty structure if loading fails
                return { "30": {}, "75": {}, "150": {} };
            }
        };

        // Initialize WORD_TABLES - will be populated on page load
        let WORD_TABLES = {
            "80": { "10": {}, "25": {}, "50": {} },
            "95": { "10": {}, "25": {}, "50": {} }
        };
        
        // Initialize PHONEME_TABLES - will be populated on page load
        let PHONEME_TABLES = {
            "80": { "30": {}, "75": {}, "150": {} },
            "95": { "30": {}, "75": {}, "150": {} }
        };
        
        // Load both 80% and 95% tables on startup
        (async () => {
            WORD_TABLES["80"] = await loadCriticalDifferenceTables(80);
            WORD_TABLES["95"] = await loadCriticalDifferenceTables(95);
            PHONEME_TABLES["80"] = await loadPhonemeTables(80);
            PHONEME_TABLES["95"] = await loadPhonemeTables(95);
            console.log("Critical difference tables loaded from CSV files");
        })();



        // --- HELPER FUNCTIONS ---
        // Same list getter, stats calc, critical limits as before
        const getListData = (listId) => {
            switch(listId) { case '1A': return LIST_1A; case '2A': return LIST_2A; case '3A': return LIST_3A; case '4A': return LIST_4A; case 'HF1': return LIST_HF1; case 'HF2': return LIST_HF2; default: return LIST_1A; }
        };

        const calculateStats = (listId, section, scores, limitTo10 = false) => {
            const allWords = getListData(listId);
            let visibleWords = allWords;
            if (section === 'first') visibleWords = allWords.slice(0, 25);
            else if (section === 'first_10') visibleWords = allWords.slice(0, 10);
            else if (section === 'second') visibleWords = allWords.slice(25, 50);
            else if (section === 'second_10') visibleWords = allWords.slice(25, 35);
            else if (section === 'full') visibleWords = allWords;

            if (limitTo10) { visibleWords = visibleWords.slice(0, 10); }

            let totalPhonemes = 0; let correctPhonemes = 0; let correctWords = 0; let totalWords = visibleWords.length;
            visibleWords.forEach(word => {
                let wordCorrectCount = 0; let wordPhonemeCount = 0;
                word.p.forEach((phoneme, pIndex) => {
                    if (phoneme === '-') return;
                    wordPhonemeCount++; totalPhonemes++;
                    const key = `${listId}_${word.i}_${pIndex}`;
                    if (scores[key]) { correctPhonemes++; wordCorrectCount++; }
                });
                if (wordCorrectCount === wordPhonemeCount && wordPhonemeCount > 0) { correctWords++; }
            });
            return {
                totalPhonemes, correctPhonemes, phonemePercent: totalPhonemes === 0 ? 0 : Math.round((correctPhonemes / totalPhonemes) * 100),
                correctWords, totalWords, wordPercent: totalWords === 0 ? 0 : Math.round((correctWords / totalWords) * 100), visibleWords
            };
        };

        const getTheta = (x, n) => Math.asin(Math.sqrt(x / (n + 1))) + Math.asin(Math.sqrt((x + 1) / (n + 1)));
        
        const getCriticalLimits = (scorePercent, n, confidence, isPhoneme = false) => {
            const confKey = String(confidence); // "80" or "95"
            let table = null;

            if (isPhoneme) {
                // Determine closest N for phoneme table lookup (30, 75, 150)
                let tableN;
                if (n <= 45) tableN = "30";
                else if (n <= 110) tableN = "75";
                else tableN = "150";
                
                if (PHONEME_TABLES[confKey]) table = PHONEME_TABLES[confKey][tableN];
            } else {
                // Determine closest N for word table lookup (10, 25, 50)
                let tableN;
                if (n <= 15) tableN = "10";
                else if (n <= 35) tableN = "25";
                else tableN = "50";

                if (WORD_TABLES[confKey]) table = WORD_TABLES[confKey][tableN];
            }

            if (table) {
                // Find exact match or closest key in table
                let bestKey = null;
                let minDiff = Infinity;
                
                Object.keys(table).forEach(key => {
                    const keyNum = parseFloat(key);
                    const diff = Math.abs(keyNum - scorePercent);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestKey = key;
                    }
                });

                if (bestKey !== null) {
                    const range = table[bestKey];
                    return { lower: range[0], upper: range[1] };
                }
            }
            
            // Fallback for edge cases where table lookup might fail (should rarely happen)
            // Default to 0-100 to be safe and obvious that it failed
            console.warn("Table lookup failed for", scorePercent, n, confidence);
            return { lower: 0, upper: 100 };
        };

        const getInterpolatedCriticalLimits = (scorePercent, n, confidence) => {
            let tableN;
            if (n <= 45) tableN = "30";
            else if (n <= 110) tableN = "75";
            else tableN = "150";

            const confKey = String(confidence);
            if (!PHONEME_TABLES[confKey] || !PHONEME_TABLES[confKey][tableN]) return getCriticalLimits(scorePercent, n, confidence, true);

            const table = PHONEME_TABLES[confKey][tableN];
            const keys = Object.keys(table).map(parseFloat).sort((a, b) => a - b);
            
            // Find neighbors
            let lowerKey = keys[0];
            let upperKey = keys[keys.length - 1];
            
            for (let i = 0; i < keys.length - 1; i++) {
                if (scorePercent >= keys[i] && scorePercent <= keys[i+1]) {
                    lowerKey = keys[i];
                    upperKey = keys[i+1];
                    break;
                }
            }
            
            if (lowerKey === upperKey) {
                 const range = table[String(lowerKey.toFixed(1))] || table[String(lowerKey.toFixed(0))] || table[String(lowerKey)];
                 return { lower: range[0], upper: range[1] };
            }

            const rangeLower = table[String(lowerKey.toFixed(1))] || table[String(lowerKey)];
            const rangeUpper = table[String(upperKey.toFixed(1))] || table[String(upperKey)];
            
            if (!rangeLower || !rangeUpper) return getCriticalLimits(scorePercent, n, confidence, true);

            const ratio = (scorePercent - lowerKey) / (upperKey - lowerKey);
            const interpolatedLower = rangeLower[0] + (rangeUpper[0] - rangeLower[0]) * ratio;
            const interpolatedUpper = rangeLower[1] + (rangeUpper[1] - rangeLower[1]) * ratio;
            
            return { lower: interpolatedLower, upper: interpolatedUpper };
        };

        function generateData(n, confidence, isPhoneme) {
            const data = [];
            if (isPhoneme) {
                 // Interpolate for smooth curves for phonemes
                 for (let score = 0; score <= 100; score += 1) {
                    const limits = getInterpolatedCriticalLimits(score, n, confidence);
                    const margin = (limits.upper - limits.lower) / 2;
                    data.push({x: score, y: margin});
                 }
            } else {
                 // For Words, maintain discrete steps
                 for (let i = 0; i <= n; i++) {
                    const score = (i / n) * 100;
                    const limits = getCriticalLimits(score, n, confidence, false);
                    const margin = (limits.upper - limits.lower) / 2;
                    data.push({x: score, y: margin});
                }
            }
            return data;
        }

        // --- COMPONENTS ---

        const LoginModal = ({ onLogin, isSetup }) => {
            const [password, setPassword] = useState('');
            const [confirm, setConfirm] = useState('');
            const [error, setError] = useState('');

            const handleSubmit = async (e) => {
                e.preventDefault();
                setError('');
                if (isSetup) {
                    const success = await window.SecureDB.login(password);
                    if (success) onLogin();
                    else setError("Incorrect password.");
                } else {
                    if (password !== confirm) { setError("Passwords do not match."); return; }
                    if (password.length < 6) { setError("Password must be at least 6 characters."); return; }
                    try {
                        await window.SecureDB.setupPassword(password);
                        onLogin();
                    } catch (err) {
                        setError("Setup failed.");
                    }
                }
            };

            return (
                <div className="fixed inset-0 bg-slate-900 z-50 flex items-center justify-center p-4">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-md p-8 relative">
                        <div className="flex justify-center mb-6 text-blue-600"><Lock className="w-12 h-12" /></div>
                        <h2 className="text-2xl font-bold text-center text-slate-800 mb-2">{isSetup ? "Unlock Database" : "Set Encryption Password"}</h2>
                        <p className="text-center text-slate-500 mb-6 text-sm">{isSetup ? "Enter your password to access patient records." : "Create a password to encrypt your local database. If you lose this, data cannot be recovered."}</p>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div><label className="block text-xs font-bold text-slate-500 mb-1 uppercase">Password</label><input type="password" value={password} onChange={e => setPassword(e.target.value)} className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" autoFocus /></div>
                            {!isSetup && (<div><label className="block text-xs font-bold text-slate-500 mb-1 uppercase">Confirm Password</label><input type="password" value={confirm} onChange={e => setConfirm(e.target.value)} className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" /></div>)}
                            {error && <div className="text-red-600 text-sm text-center font-medium">{error}</div>}
                            <button type="submit" className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-bold transition-colors">{isSetup ? "Unlock" : "Set Password & Unlock"}</button>
                        </form>
                    </div>
                </div>
            );
        };

        const PhonemeFrequencyModal = ({ isOpen, onClose }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
                    <div className="bg-white rounded-xl shadow-lg w-full max-w-2xl p-6 relative">
                        <button onClick={onClose} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><X className="w-6 h-6" /></button>
                        <h3 className="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2"><Activity className="w-5 h-5 text-blue-600" /> Phoneme Frequency Guide</h3>
                        <div className="overflow-x-auto">
                            <table className="w-full text-sm text-left border-collapse">
                                <thead className="bg-slate-100 text-slate-600 font-semibold border-b border-slate-200"><tr><th className="px-4 py-2 border-r border-slate-200">Class</th><th className="px-4 py-2 border-r border-slate-200">Examples</th><th className="px-4 py-2">Critical Frequency Range</th></tr></thead>
                                <tbody className="divide-y divide-slate-100">
                                    <tr className="hover:bg-slate-50"><td className="px-4 py-2 font-medium text-slate-700 border-r border-slate-200">Vowels</td><td className="px-4 py-2 text-slate-600 border-r border-slate-200">/i, u, a/</td><td className="px-4 py-2 text-slate-800"><strong>Low/Mid</strong> (F1: 250-1000 Hz, F2: 800-2500 Hz)</td></tr>
                                    <tr className="hover:bg-slate-50 bg-slate-50/50"><td className="px-4 py-2 font-medium text-slate-700 border-r border-slate-200">Nasals</td><td className="px-4 py-2 text-slate-600 border-r border-slate-200">/m, n, ŋ/</td><td className="px-4 py-2 text-slate-800"><strong>Low</strong> (~250-500 Hz Murmur)</td></tr>
                                    <tr className="hover:bg-slate-50"><td className="px-4 py-2 font-medium text-slate-700 border-r border-slate-200">Liquids/Glides</td><td className="px-4 py-2 text-slate-600 border-r border-slate-200">/l, r, w, j/</td><td className="px-4 py-2 text-slate-800"><strong>Low/Mid</strong> (Formant transitions 500-2000 Hz)</td></tr>
                                    <tr className="hover:bg-slate-50 bg-slate-50/50"><td className="px-4 py-2 font-medium text-slate-700 border-r border-slate-200">Stops</td><td className="px-4 py-2 text-slate-600 border-r border-slate-200">/p, t, k, b, d, g/</td><td className="px-4 py-2 text-slate-800"><strong>Mid/High</strong> (Burst energy 1500 - 4000+ Hz)</td></tr>
                                    <tr className="hover:bg-slate-50"><td className="px-4 py-2 font-medium text-slate-700 border-r border-slate-200">Fricatives</td><td className="px-4 py-2 text-slate-600 border-r border-slate-200">/f, s, ʃ, θ/</td><td className="px-4 py-2 text-slate-800"><strong>High</strong> (Turbulence 2500 - 8000+ Hz)</td></tr>
                                    <tr className="hover:bg-slate-50 bg-slate-50/50"><td className="px-4 py-2 font-medium text-slate-700 border-r border-slate-200">Affricates</td><td className="px-4 py-2 text-slate-600 border-r border-slate-200">/tʃ, dʒ/</td><td className="px-4 py-2 text-slate-800"><strong>Mid/High</strong> (Wide range 2000 - 8000 Hz)</td></tr>
                                </tbody>
                            </table>
                        </div>
                        <div className="mt-4 text-center"><button onClick={onClose} className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-colors">Close</button></div>
                    </div>
                </div>
            );
        };

        const DiagnosticsPanel = ({ stats, scores, listId }) => {
            const chartRef = useRef(null);
            const canvasRef = useRef(null);
            const [showInfo, setShowInfo] = useState(false);

            const breakdown = useMemo(() => {
                const groups = { "High Frequency (Fricatives, Affricates, Stops)": { total: 0, missed: 0, types: ["Fricative", "Affricate", "Stop"] }, "Low Frequency (Nasals, Liquids, Glides, Vowels)": { total: 0, missed: 0, types: ["Nasal", "Liquid/Glide", "Vowel"] } };
                const details = { Fricative: { total: 0, missed: 0 }, Affricate: { total: 0, missed: 0 }, Stop: { total: 0, missed: 0 }, Nasal: { total: 0, missed: 0 }, "Liquid/Glide": { total: 0, missed: 0 }, Vowel: { total: 0, missed: 0 } };
                
                // Feature-based analysis
                const mannerErrors = {}, placeErrors = {}, voicingErrors = { Voiced: { total: 0, missed: 0 }, Voiceless: { total: 0, missed: 0 } };

                stats.visibleWords.forEach(word => {
                    word.p.forEach((p, idx) => {
                        if (p === '-') return;
                        const type = PHONEME_MAP[p];
                        const isCorrect = scores[`${listId}_${word.i}_${idx}`];
                        const features = PHONEME_FEATURES[p];
                        
                        if (type) {
                            if(details[type]) { details[type].total++; if (!isCorrect) details[type].missed++; }
                            if (groups["High Frequency (Fricatives, Affricates, Stops)"].types.includes(type)) { groups["High Frequency (Fricatives, Affricates, Stops)"].total++; if (!isCorrect) groups["High Frequency (Fricatives, Affricates, Stops)"].missed++; }
                            else if (groups["Low Frequency (Nasals, Liquids, Glides, Vowels)"].types.includes(type)) { groups["Low Frequency (Nasals, Liquids, Glides, Vowels)"].total++; if (!isCorrect) groups["Low Frequency (Nasals, Liquids, Glides, Vowels)"].missed++; }
                        }
                        
                        if (features) {
                            const { manner, place, voicing } = features;
                            
                            if (manner) {
                                if (!mannerErrors[manner]) mannerErrors[manner] = { total: 0, missed: 0 };
                                mannerErrors[manner].total++;
                                if (!isCorrect) mannerErrors[manner].missed++;
                            }
                            
                            if (place) {
                                if (!placeErrors[place]) placeErrors[place] = { total: 0, missed: 0 };
                                placeErrors[place].total++;
                                if (!isCorrect) placeErrors[place].missed++;
                            }
                            
                            if (voicing) {
                                voicingErrors[voicing].total++;
                                if (!isCorrect) voicingErrors[voicing].missed++;
                            }
                        }
                    });
                });
                return { groups, details, mannerErrors, placeErrors, voicingErrors };
            }, [stats, scores, listId]);

            useEffect(() => {
                if (!canvasRef.current) return;
                const ctx = canvasRef.current.getContext('2d');
                if (chartRef.current) { chartRef.current.destroy(); }
                const labels = Object.keys(breakdown.details).filter(k => breakdown.details[k].total > 0);
                const data = labels.map(k => { const d = breakdown.details[k]; return Math.round((d.missed / d.total) * 100); });
                chartRef.current = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: '% Errors', data: data, backgroundColor: 'rgba(239, 68, 68, 0.6)', borderColor: 'rgb(239, 68, 68)', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, indexAxis: 'y', plugins: { legend: { display: false }, title: { display: true, text: 'Error Rate by Category' } }, scales: { x: { beginAtZero: true, max: 100, title: { display: true, text: '% Missed' } } } } });
                return () => { if (chartRef.current) chartRef.current.destroy(); };
            }, [breakdown]);

            return (
                <div className="bg-slate-50 border-t border-slate-200 p-4 space-y-4">
                    <PhonemeFrequencyModal isOpen={showInfo} onClose={() => setShowInfo(false)} />
                    <div className="flex items-center gap-2 mb-3"><h4 className="text-sm font-bold text-slate-700 flex items-center gap-2"><Activity className="w-4 h-4 text-blue-600" /> Automated Error Pattern Analysis</h4><button onClick={() => setShowInfo(true)} className="text-slate-400 hover:text-blue-600 transition-colors" title="View Phoneme Frequency Guide"><HelpCircle className="w-4 h-4" /></button></div>
                    
                    {/* Feature-based error summary */}
                    <div className="bg-white rounded-lg border border-slate-200 p-3 shadow-sm">
                        <h5 className="text-xs font-bold text-slate-600 uppercase tracking-wide mb-2 border-b border-slate-100 pb-2">Error Summary by Feature</h5>
                        <div className="grid grid-cols-3 gap-4 text-sm">
                            {/* Manner Errors */}
                            {breakdown && breakdown.mannerErrors && (() => {
                                let totalManner = 0, missedManner = 0;
                                Object.values(breakdown.mannerErrors).forEach(data => { totalManner += data.total; missedManner += data.missed; });
                                const pct = totalManner > 0 ? Math.round((missedManner / totalManner) * 100) : 0;
                                return (
                                    <div className="text-center">
                                        <div className="font-semibold text-slate-700 mb-1">Manner</div>
                                        <div className={`text-2xl font-bold ${pct > 0 ? 'text-red-600' : 'text-slate-400'}`}>{pct}%</div>
                                    </div>
                                );
                            })()}
                            
                            {/* Place Errors */}
                            {breakdown && breakdown.placeErrors && (() => {
                                let totalPlace = 0, missedPlace = 0;
                                Object.values(breakdown.placeErrors).forEach(data => { totalPlace += data.total; missedPlace += data.missed; });
                                const pct = totalPlace > 0 ? Math.round((missedPlace / totalPlace) * 100) : 0;
                                return (
                                    <div className="text-center">
                                        <div className="font-semibold text-slate-700 mb-1">Place</div>
                                        <div className={`text-2xl font-bold ${pct > 0 ? 'text-red-600' : 'text-slate-400'}`}>{pct}%</div>
                                    </div>
                                );
                            })()}
                            
                            {/* Voicing Errors */}
                            {breakdown && breakdown.voicingErrors && (() => {
                                let totalVoicing = 0, missedVoicing = 0;
                                Object.values(breakdown.voicingErrors).forEach(data => { totalVoicing += data.total; missedVoicing += data.missed; });
                                const pct = totalVoicing > 0 ? Math.round((missedVoicing / totalVoicing) * 100) : 0;
                                return (
                                    <div className="text-center">
                                        <div className="font-semibold text-slate-700 mb-1">Voicing</div>
                                        <div className={`text-2xl font-bold ${pct > 0 ? 'text-red-600' : 'text-slate-400'}`}>{pct}%</div>
                                    </div>
                                );
                            })()}
                        </div>
                    </div>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div className="space-y-3">
                            <div className="bg-white p-3 rounded-lg border border-slate-200 shadow-sm h-56 relative"><canvas ref={canvasRef}></canvas></div>
                            {breakdown && breakdown.groups && Object.entries(breakdown.groups).map(([name, data]) => { const percent = data.total > 0 ? Math.round((data.missed / data.total) * 100) : 0; return ( <div key={name} className="bg-white p-3 rounded-lg border border-slate-200 shadow-sm"> <div className="flex justify-between items-center mb-1"> <span className="text-xs font-bold text-slate-600 uppercase tracking-wide">{name}</span> <span className={`text-xs font-bold ${percent > 30 ? 'text-red-600' : 'text-slate-500'}`}>{percent}% Missed</span> </div> <div className="w-full bg-slate-100 rounded-full h-2 mb-1"> <div className={`h-2 rounded-full ${percent > 50 ? 'bg-red-500' : 'bg-blue-500'}`} style={{ width: `${percent}%` }}></div> </div> <div className="text-[10px] text-slate-400 text-right">{data.missed} / {data.total} phonemes</div> </div> ); })}
                        </div>
                        <div className="bg-white p-3 rounded-lg border border-slate-200 shadow-sm"><h5 className="text-xs font-bold text-slate-500 uppercase tracking-wide mb-3 border-b border-slate-100 pb-2">Error Analysis by Type</h5><div className="grid grid-cols-2 gap-y-2 gap-x-4">{breakdown && breakdown.details && Object.entries(breakdown.details).map(([type, data]) => { if(data.total === 0) return null; const pct = Math.round((data.missed / data.total) * 100); return ( <div key={type} className="flex justify-between items-center text-xs"> <span className="text-slate-600">{type}</span> <span className={`font-mono ${pct > 0 ? 'text-red-600 font-bold' : 'text-slate-400'}`}> {data.missed}/{data.total} ({pct}%) </span> </div> ); })}</div></div>
                    </div>
                </div>
            );
        };

        const CriticalDifferenceModal = ({ isOpen, onClose, confidenceLevel }) => {
            const chartRef = useRef(null);
            const canvasRef = useRef(null);
            const [viewMode, setViewMode] = useState('words'); // 'words' or 'phonemes'
            const [selectedN, setSelectedN] = useState('50'); // '10','25','50' for words; '30','75','150' for phonemes
            const [tableData, setTableData] = useState([]);
            const [isTableView, setIsTableView] = useState(true); // Default to Table View

            useEffect(() => {
                if(viewMode === 'words') {
                     // Ensure valid N for words
                     if(['10','25','50'].indexOf(selectedN) === -1) setSelectedN('50');
                } else {
                    if(['30','75','150'].indexOf(selectedN) === -1) setSelectedN('150');
                }
            }, [viewMode]);

            useEffect(() => {
                const n = parseInt(selectedN);
                const isPhoneme = viewMode === 'phonemes';
                const data = [];
                
                // Always generate discrete integer steps for the table view
                // This ensures we match the specific count/score alignment of the test
                for (let i = 0; i <= n; i++) {
                    const score = (i / n) * 100;
                    const limits = getCriticalLimits(score, n, confidenceLevel, isPhoneme);
                    data.push({
                        count: i,
                        score: score,
                        lower: limits.lower,
                        upper: limits.upper
                    });
                }
                setTableData(data);
                
                // If chart view is active, update chart
                if (!isTableView && canvasRef.current) {
                    if (chartRef.current) { chartRef.current.destroy(); }
                    
                    const ctx = canvasRef.current.getContext('2d');
                    
                    // Regenerate ALL datasets for the chart context
                    const data10 = generateData(10, confidenceLevel, false); 
                    const data25 = generateData(25, confidenceLevel, false); 
                    const data30 = generateData(30, confidenceLevel, true);
                    const data50 = generateData(50, confidenceLevel, false); 
                    const data75 = generateData(75, confidenceLevel, true); 
                    const data150 = generateData(150, confidenceLevel, true);
                    
                    chartRef.current = new Chart(ctx, {
                        type: 'line',
                        data: {
                            datasets: [
                                { label: 'N = 10 (Words)', data: data10, borderColor: '#9467bd', borderDash: [5, 5], borderWidth: 2, pointRadius: 0, fill: false, tension: 0.4 },
                                { label: 'N = 25 (Words)', data: data25, borderColor: '#d62728', borderDash: [5, 5], borderWidth: 2, pointRadius: 0, fill: false, tension: 0.4 },
                                { label: 'N = 50 (Words)', data: data50, borderColor: '#ff7f0e', borderDash: [5, 5], borderWidth: 2, pointRadius: 0, fill: false, tension: 0.4 },
                                { label: 'N = 30 (Phonemes)', data: data30, borderColor: '#17becf', borderWidth: 2, pointRadius: 0, fill: false, tension: 0.4 },
                                { label: 'N = 75 (Phonemes)', data: data75, borderColor: '#2ca02c', borderWidth: 2, pointRadius: 0, fill: false, tension: 0.4 },
                                { label: 'N = 150 (Phonemes)', data: data150, borderColor: '#1f77b4', borderWidth: 2, pointRadius: 0, fill: false, tension: 0.4 }
                            ]
                        },
                        options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false, }, plugins: { title: { display: true, text: `Critical Difference Ranges (${confidenceLevel}% Confidence)` }, tooltip: { callbacks: { label: function(context) { return context.dataset.label + ': ±' + context.parsed.y.toFixed(1) + '%'; } } } }, scales: { x: { type: 'linear', title: { display: true, text: 'Score (%)' }, min: 0, max: 100 }, y: { title: { display: true, text: 'Margin of Error (+/- %)' }, min: 0, suggestedMax: 30 } } }
                    });
                }
            }, [selectedN, confidenceLevel, viewMode, isTableView, isOpen]);

            if (!isOpen) return null;

            return (
                 <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
                    <div className="bg-white rounded-xl shadow-lg w-full max-w-4xl p-6 relative flex flex-col max-h-[90vh]">
                        <button onClick={onClose} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><X className="w-6 h-6" /></button>
                        
                        <div className="mb-4">
                            <h3 className="text-xl font-bold text-slate-800 mb-2">Critical Difference Tables ({confidenceLevel}% Confidence)</h3>
                            
                            <div className="flex gap-4 mb-4 border-b border-slate-200 pb-2">
                                <button onClick={() => setViewMode('words')} className={`pb-2 text-sm font-bold transition-colors ${viewMode === 'words' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-slate-500 hover:text-slate-700'}`}>Whole Word Scoring (Monte Carlo)</button>
                                <button onClick={() => setViewMode('phonemes')} className={`pb-2 text-sm font-bold transition-colors ${viewMode === 'phonemes' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-slate-500 hover:text-slate-700'}`}>Phoneme Scoring (Monte Carlo)</button>
                            </div>

                            <div className="flex gap-2">
                                {viewMode === 'words' ? (
                                    <>
                                        <button onClick={() => setSelectedN('10')} className={`px-3 py-1.5 rounded-lg text-xs font-bold transition ${selectedN === '10' ? 'bg-slate-800 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'}`}>N = 10</button>
                                        <button onClick={() => setSelectedN('25')} className={`px-3 py-1.5 rounded-lg text-xs font-bold transition ${selectedN === '25' ? 'bg-slate-800 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'}`}>N = 25</button>
                                        <button onClick={() => setSelectedN('50')} className={`px-3 py-1.5 rounded-lg text-xs font-bold transition ${selectedN === '50' ? 'bg-slate-800 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'}`}>N = 50</button>
                                    </>
                                ) : (
                                    <>
                                        <button onClick={() => setSelectedN('30')} className={`px-3 py-1.5 rounded-lg text-xs font-bold transition ${selectedN === '30' ? 'bg-slate-800 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'}`}>N = 30</button>
                                        <button onClick={() => setSelectedN('75')} className={`px-3 py-1.5 rounded-lg text-xs font-bold transition ${selectedN === '75' ? 'bg-slate-800 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'}`}>N = 75</button>
                                        <button onClick={() => setSelectedN('150')} className={`px-3 py-1.5 rounded-lg text-xs font-bold transition ${selectedN === '150' ? 'bg-slate-800 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'}`}>N = 150</button>
                                    </>
                                )}
                            </div>
                        </div>

                        <div className="flex-1 overflow-y-auto border rounded-lg border-slate-200 custom-scrollbar">
                            <table className="w-full text-sm text-left relative">
                                <thead className="bg-slate-50 text-slate-600 font-bold text-xs uppercase sticky top-0 shadow-sm">
                                    <tr>
                                        <th className="px-4 py-3 border-b">Score (Count)</th>
                                        <th className="px-4 py-3 border-b text-center">Score (%)</th>
                                        <th className="px-4 py-3 border-b text-center text-red-600">Lower Limit</th>
                                        <th className="px-4 py-3 border-b text-center text-emerald-600">Upper Limit</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-slate-100">
                                    {tableData.length > 0 ? (
                                        tableData.map((row, idx) => {
                                            const n = parseInt(selectedN);
                                            return (
                                                <tr key={idx} className="hover:bg-blue-50">
                                                    <td className="px-4 py-2 font-mono text-slate-500">{row.count} / {n}</td>
                                                    <td className="px-4 py-2 font-bold text-center text-slate-800">{row.score.toFixed(1)}%</td>
                                                    <td className="px-4 py-2 text-center text-slate-600">{row.lower.toFixed(1)}%</td>
                                                    <td className="px-4 py-2 text-center text-slate-600">{row.upper.toFixed(1)}%</td>
                                                </tr>
                                            )
                                        })
                                    ) : (
                                        <tr><td colSpan="4" className="text-center py-4 text-slate-500">Loading data...</td></tr>
                                    )}
                                </tbody>
                            </table>
                        </div>
                        
                        <div className="mt-4 text-center">
                            <button onClick={onClose} className="px-6 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg font-medium transition-colors">Close</button>
                        </div>
                    </div>
                </div>
            );
        };

        const ListeningEffortScaleModal = ({ isOpen, onClose }) => {
            if (!isOpen) return null;
            const downloadScale = async () => {
                const element = document.getElementById('scale-capture-target'); if (!element) return;
                try { const canvas = await html2canvas(element, { backgroundColor: '#ffffff', scale: 2 }); const data = canvas.toDataURL('image/png'); const link = document.createElement('a'); link.href = data; link.download = 'listening-effort-scale.png'; link.click(); } catch (error) { console.error("Download failed:", error); alert("Could not export PNG. Try printing instead."); }
            };
            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"> <div className="bg-white rounded-xl shadow-lg max-w-lg w-full p-4 relative max-h-[90vh] overflow-y-auto"> <button onClick={onClose} className="absolute top-3 right-3 text-slate-400 hover:text-slate-600 no-print"> <X className="w-5 h-5" /> </button> <div id="scale-capture-target" className="p-2 bg-white"> <h3 className="text-lg font-bold text-slate-800 mb-3 text-center">Listening Effort Scale</h3> <div className="space-y-1"> {[ { val: 0, label: "No Effort", color: "bg-emerald-100 border-emerald-300 text-emerald-800" }, { val: 1, label: "Very Little Effort", color: "bg-emerald-50 border-emerald-200 text-emerald-700" }, { val: 2, label: "Little Effort", color: "bg-green-50 border-green-200 text-green-700" }, { val: 3, label: "Moderate Effort", color: "bg-lime-50 border-lime-200 text-lime-700" }, { val: 4, label: "Considerable Effort", color: "bg-yellow-50 border-yellow-200 text-yellow-700" }, { val: 5, label: "Much Effort", color: "bg-amber-50 border-amber-200 text-amber-700" }, { val: 6, label: "Very Much Effort", color: "bg-orange-50 border-orange-200 text-orange-700" }, { val: 7, label: "Extreme Effort", color: "bg-red-50 border-red-200 text-red-700" }, { val: 8, label: "Maximum Effort", color: "bg-red-100 border-red-300 text-red-800" }, { val: 9, label: "Giving Up", color: "bg-rose-100 border-rose-300 text-rose-800" }, { val: 10, label: "Unable to Ignore Noise", color: "bg-slate-800 border-slate-900 text-white" }, ].map((item) => ( <div key={item.val} className={`flex items-center gap-3 p-1.5 rounded border ${item.color}`}> <span className="font-bold text-base w-6 text-center">{item.val}</span> <span className="font-medium text-sm">{item.label}</span> </div> ))} </div> </div> <div className="mt-4 text-center flex gap-2 justify-center no-print"> <button onClick={downloadScale} className="px-4 py-1.5 bg-blue-100 hover:bg-blue-200 text-blue-700 rounded-lg text-sm font-medium flex items-center gap-1"><Download className="w-4 h-4"/> PNG</button> <button onClick={onClose} className="px-4 py-1.5 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg text-sm font-medium">Close</button> </div> </div> </div>
            );
        };

        const PhonemeDisclaimerModal = ({ isOpen, onClose }) => {
            if (!isOpen) return null;
            return ( <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"> <div className="bg-white rounded-xl shadow-lg max-w-sm w-full p-6 relative"> <button onClick={onClose} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"> <X className="w-5 h-5" /> </button> <div className="flex flex-col items-center text-center"> <div className="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center mb-4 text-blue-600"> <AlertCircle className="w-6 h-6" /> </div> <h3 className="text-lg font-bold text-slate-800 mb-2">Phoneme Scoring Note</h3> <p className="text-sm text-slate-600 mb-6 leading-relaxed"> Phoneme scores are typically about <strong>20% better</strong> than whole word scores. You may want to use a <strong>lower (more difficult) SNR</strong> to avoid ceiling effects. </p> <button onClick={onClose} className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium w-full transition-colors"> Got it </button> </div> </div> </div> );
        };

        const LoadTestModal = ({ isOpen, onClose, onLoad }) => {
            const [tests, setTestsList] = useState([]);
            const [loading, setLoading] = useState(true);
            const [search, setSearch] = useState("");

            useEffect(() => {
                if(!isOpen) return;
                setLoading(true);
                window.SecureDB.getAllTests().then(data => {
                    setTestsList(data);
                    setLoading(false);
                }).catch(err => {
                    console.error("Error fetching local tests:", err);
                    setLoading(false);
                });
            }, [isOpen]);

        // ImportPreviewModal moved to top-level

            const handleDelete = async (testId, e) => {
                e.stopPropagation();
                if(confirm("Are you sure you want to delete this test? This cannot be undone.")) {
                    try {
                        await window.SecureDB.deleteTest(testId);
                        const updated = await window.SecureDB.getAllTests();
                        setTestsList(updated);
                    } catch(err) { console.error("Error deleting:", err); alert("Delete failed"); }
                }
            };

            const filtered = tests.filter(t =>
                (t.patientName || "").toLowerCase().includes(search.toLowerCase()) ||
                (t.cNumber || "").toLowerCase().includes(search.toLowerCase())
            );

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
                    <div className="bg-white rounded-xl shadow-lg w-full max-w-2xl p-6 relative flex flex-col max-h-[80vh]">
                        <button onClick={onClose} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><X className="w-6 h-6" /></button>
                        <h3 className="text-xl font-bold text-slate-800 mb-4">Load Patient History (Secure)</h3>

                        <div className="relative mb-4">
                            <Search className="absolute left-3 top-2.5 text-slate-400 w-5 h-5" />
                            <input type="text" value={search} onChange={(e) => setSearch(e.target.value)} placeholder="Search by Name or ID..." className="w-full pl-10 pr-4 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" />
                        </div>

                        <div className="flex-1 overflow-y-auto space-y-2 pr-2">
                            {loading ? <div className="text-center py-8 text-slate-500"><Loader className="w-8 h-8 mx-auto mb-2 text-blue-600"/>Loading records...</div> :
                             filtered.length === 0 ? <div className="text-center py-8 text-slate-500 italic">No matching records found in secure database.</div> :
                             filtered.map(test => (
                                <div key={test.id} onClick={() => { onLoad(test); onClose(); }} className="p-3 border border-slate-200 rounded-lg hover:bg-slate-50 hover:border-blue-300 cursor-pointer transition group flex justify-between items-center">
                                    <div>
                                        <div className="font-bold text-slate-800">{test.patientName} <span className="text-slate-400 font-normal">#{test.cNumber}</span></div>
                                        <div className="text-xs text-slate-500">{test.testDate} • {test.tests.A.condition} vs {test.tests.B.condition}</div>
                                    </div>
                                    <button onClick={(e) => handleDelete(test.id, e)} className="p-2 text-slate-300 hover:text-red-500 hover:bg-red-50 rounded-full transition opacity-0 group-hover:opacity-100"><Trash2 className="w-4 h-4" /></button>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        // Import Preview Modal (top-level)
        const ImportPreviewModal = ({ isOpen, onClose, fileName, records, invalidCount, onImportOverwrite, onImportAppend, onImportSkip, onImportMerge, onImportUseSelected, defaultMode }) => {
            if (!isOpen) return null;
            const sample = (records || []).slice(0,5);
            const modeLabels = { append: 'Append', skip: 'Skip duplicates', overwrite: 'Overwrite', merge: 'Merge duplicates' };
            const selectedLabel = modeLabels[defaultMode] || 'Append';
            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
                    <div className="bg-white rounded-xl shadow-lg w-full max-w-2xl p-6 relative max-h-[80vh] overflow-y-auto">
                        <button onClick={() => { onClose(); if (fileInputRef && fileInputRef.current) fileInputRef.current.value = ''; }} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><X className="w-6 h-6" /></button>
                        <h3 className="text-xl font-bold text-slate-800 mb-2">Import Preview</h3>
                        <div className="text-sm text-slate-500 mb-4">File: <span className="font-mono">{fileName}</span></div>
                        <div className="mb-4">
                            <div className="text-sm">Total records: <span className="font-bold">{records?.length || 0}</span></div>
                            <div className="text-sm">Invalid records detected: <span className="font-bold">{invalidCount}</span></div>
                        </div>

                        <div className="mb-3 text-xs text-slate-500">Import options: <span className="font-medium">Append</span> (import as new records), <span className="font-medium">Skip duplicates</span> (ignore records with same ID), <span className="font-medium">Overwrite</span> (replace existing records by ID), or <span className="font-medium">Merge duplicates</span> (combine matching IDs or patient/date records). The <span className="font-medium">selected</span> mode before opening this modal is shown below.</div>

                        <div className="mb-4">
                            <div className="text-sm font-bold text-slate-600 mb-1">Selected mode</div>
                            <div className="text-sm text-slate-700 mb-2">{selectedLabel}</div>
                        </div>

                        <div className="space-y-2 mb-4">
                            <div className="text-sm font-bold text-slate-600 mb-2">Sample entries</div>
                            {(sample.length === 0) ? <div className="text-sm text-slate-500 italic">No sample entries available.</div> : sample.map((r, idx) => (
                                <div key={idx} className="p-2 border rounded bg-slate-50">
                                    <div className="font-bold text-slate-800">{r.patientName || '(No name)'} <span className="text-slate-400 font-normal">#{r.cNumber || '—'}</span></div>
                                    <div className="text-xs text-slate-500">{r.testDate || '—'} • {r.tests?.A?.listId || '—'}</div>
                                    <div className="text-xs text-slate-500 mt-1">Notes: {r.notes || '—'}</div>
                                </div>
                            ))}
                        </div>

                        <div className="flex gap-2 justify-end">
                            <button onClick={() => { onImportAppend(); }} className="px-4 py-2 bg-slate-100 rounded text-slate-700">Import (Append as New IDs)</button>
                            <button onClick={() => { onImportSkip(); }} className="px-4 py-2 bg-yellow-100 rounded text-yellow-800">Import (Skip duplicates)</button>
                            <button onClick={() => { onImportMerge(); }} className="px-4 py-2 bg-emerald-100 rounded text-emerald-800">Import (Merge duplicates)</button>
                            <button onClick={() => { onImportOverwrite(); }} className="px-4 py-2 bg-blue-600 rounded text-white">Import (Overwrite by ID)</button>
                            <button onClick={() => onImportUseSelected()} className="px-4 py-2 bg-green-600 rounded text-white">Import (Use Selected: {selectedLabel})</button>
                            <button onClick={() => { onClose(); if (fileInputRef && fileInputRef.current) fileInputRef.current.value = ''; }} className="px-4 py-2 bg-white border rounded">Cancel</button>
                        </div>
                    </div>
                </div>
            );
        };

        const HistoryChart = ({ cNumber }) => {
            const canvasRef = useRef(null);
            const chartRef = useRef(null);
            const [historyData, setHistoryData] = useState([]);
            const [loading, setLoading] = useState(false);

            useEffect(() => {
                if (!cNumber) return;
                setLoading(true);
                window.SecureDB.getPatientHistory(cNumber).then(data => {
                    setHistoryData(data);
                    setLoading(false);
                });
            }, [cNumber]);

            useEffect(() => {
                if (!canvasRef.current || historyData.length === 0) return;

                const ctx = canvasRef.current.getContext('2d');
                if (chartRef.current) chartRef.current.destroy();

                // Ensure chronological order (oldest → newest)
                const sortedHistory = [...historyData].sort((a,b) => {
                    const da = a && a.testDate ? new Date(a.testDate) : new Date(0);
                    const db = b && b.testDate ? new Date(b.testDate) : new Date(0);
                    return da - db;
                });
                const labels = sortedHistory.map(t => t.testDate);

                const getWRS = (testObj, listId, section, scores) => {
                     const result = calculateStats(listId, section, scores, testObj.limitTo10);
                     return result.wordPercent;
                };

                const getPRS = (testObj, listId, section, scores) => {
                    const result = calculateStats(listId, section, scores, testObj.limitTo10);
                    return result.phonemePercent;
               };

                const wrsA = sortedHistory.map(r => getWRS(r.tests.A, r.tests.A.listId, r.tests.A.section, r.tests.A.scores));
                const prsA = sortedHistory.map(r => getPRS(r.tests.A, r.tests.A.listId, r.tests.A.section, r.tests.A.scores));
                const wrsB = sortedHistory.map(r => getWRS(r.tests.B, r.tests.B.listId, r.tests.B.section, r.tests.B.scores));
                const prsB = sortedHistory.map(r => getPRS(r.tests.B, r.tests.B.listId, r.tests.B.section, r.tests.B.scores));

                chartRef.current = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Test A Word',
                                data: wrsA,
                                borderColor: '#2563eb', // Blue-600 (Solid)
                                backgroundColor: '#2563eb',
                                tension: 0.1,
                                pointStyle: 'circle'
                            },
                            {
                                label: 'Test A Phoneme',
                                data: prsA,
                                borderColor: '#60a5fa', // Blue-400 (Lighter)
                                backgroundColor: '#60a5fa',
                                borderDash: [5, 5], // Dashed
                                tension: 0.1,
                                pointStyle: 'rectRot',
                                pointRadius: 4
                            },
                            {
                                label: 'Test B Word',
                                data: wrsB,
                                borderColor: '#9333ea', // Purple-600 (Solid)
                                backgroundColor: '#9333ea',
                                tension: 0.1,
                                pointStyle: 'circle'
                            },
                            {
                                label: 'Test B Phoneme',
                                data: prsB,
                                borderColor: '#c084fc', // Purple-400 (Lighter)
                                backgroundColor: '#c084fc',
                                borderDash: [5, 5], // Dashed
                                tension: 0.1,
                                pointStyle: 'rectRot',
                                pointRadius: 4
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: { beginAtZero: true, max: 100, title: { display: true, text: 'Score (%)' } }
                        },
                        plugins: {
                            tooltip: {
                                mode: 'index',
                                intersect: false
                            }
                        }
                    }
                });

                return () => { if (chartRef.current) chartRef.current.destroy(); };
            }, [historyData]);

            if (!cNumber) return <div className="text-center text-slate-400 py-10">Enter Patient ID to view history.</div>;
            if (loading) return <div className="text-center text-slate-500 py-10"><Loader className="w-8 h-8 mx-auto mb-2 text-blue-600"/>Loading history...</div>;
            if (historyData.length === 0) return <div className="text-center text-slate-400 py-10">No history found for ID: {cNumber}</div>;

            return (
                <div className="space-y-6">
                    <div className="bg-white p-4 rounded-lg border border-slate-200 h-[300px]">
                        <div className="flex items-center justify-between mb-2">
                            <div className="text-xs text-slate-500">Dates: <span className="font-medium text-slate-700">Old → New</span> <span className="text-[10px] text-slate-400 ml-2">(left → right)</span></div>
                        </div>
                        <canvas ref={canvasRef}></canvas>
                    </div>
                    <div className="bg-white rounded-lg border border-slate-200 overflow-hidden">
                        <table className="w-full text-sm text-left">
                            <thead className="bg-slate-50 text-slate-500 font-semibold border-b border-slate-200">
                                <tr>
                                    <th className="px-4 py-2">Date</th>
                                    <th className="px-4 py-2">Test A</th>
                                    <th className="px-4 py-2">Word A</th>
                                    <th className="px-4 py-2 text-blue-400">Phon A</th>
                                    <th className="px-4 py-2 border-l border-slate-100">Test B</th>
                                    <th className="px-4 py-2">Word B</th>
                                    <th className="px-4 py-2 text-purple-400">Phon B</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-100">
                                {historyData.map((record, idx) => {
                                    const statsA = calculateStats(record.tests.A.listId, record.tests.A.section, record.tests.A.scores, record.tests.A.limitTo10);
                                    const statsB = calculateStats(record.tests.B.listId, record.tests.B.section, record.tests.B.scores, record.tests.B.limitTo10);
                                    return (
                                        <tr key={record.id || idx} className="hover:bg-slate-50">
                                            <td className="px-4 py-2">{record.testDate}</td>
                                            <td className="px-4 py-2 text-slate-600">{record.tests.A.condition}</td>
                                            <td className="px-4 py-2 font-bold text-blue-600">{statsA.wordPercent}%</td>
                                            <td className="px-4 py-2 font-medium text-blue-400">{statsA.phonemePercent}%</td>

                                            <td className="px-4 py-2 text-slate-600 border-l border-slate-100">{record.tests.B.condition}</td>
                                            <td className="px-4 py-2 font-bold text-purple-600">{statsB.wordPercent}%</td>
                                            <td className="px-4 py-2 font-medium text-purple-400">{statsB.phonemePercent}%</td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        const SettingsModal = ({ isOpen, onClose, initialSettings, onSave }) => {
            const [clinicName, setClinicName] = useState(initialSettings?.clinicName || '');
            const [audiologistName, setAudiologistName] = useState(initialSettings?.audiologistName || '');
            const [licenseNumber, setLicenseNumber] = useState(initialSettings?.licenseNumber || '');

            useEffect(() => {
                if(isOpen && initialSettings) {
                    setClinicName(initialSettings.clinicName || '');
                    setAudiologistName(initialSettings.audiologistName || '');
                    setLicenseNumber(initialSettings.licenseNumber || '');
                }
            }, [isOpen, initialSettings]);

            const handleSubmit = (e) => {
                e.preventDefault();
                onSave({ clinicName, audiologistName, licenseNumber });
                onClose();
            };

            if(!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
                    <div className="bg-white rounded-xl shadow-lg w-full max-w-md p-6 relative">
                        <button onClick={onClose} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><X className="w-5 h-5"/></button>
                        <h2 className="text-xl font-bold text-slate-800 mb-4">Clinic Settings</h2>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div><label className="block text-xs font-bold text-slate-500 uppercase">Clinic Name</label><input type="text" className="w-full border p-2 rounded" value={clinicName} onChange={e => setClinicName(e.target.value)} /></div>
                            <div><label className="block text-xs font-bold text-slate-500 uppercase">Hearing Care Provider Name</label><input type="text" className="w-full border p-2 rounded" value={audiologistName} onChange={e => setAudiologistName(e.target.value)} /></div>
                            <div><label className="block text-xs font-bold text-slate-500 uppercase">License #</label><input type="text" className="w-full border p-2 rounded" value={licenseNumber} onChange={e => setLicenseNumber(e.target.value)} /></div>
                            <button type="submit" className="w-full bg-blue-600 text-white p-2 rounded hover:bg-blue-700">Save Settings</button>
                        </form>
                    </div>
                </div>
            );
        };

        // NEW: Comparative Ease Scale Modal
        const ComparativeEaseScaleModal = ({ isOpen, onClose }) => {
            if (!isOpen) return null;
            const captureRef = useRef(null);

            const handleDownload = async () => {
                if (!captureRef.current) return;
                try {
                    const canvas = await html2canvas(captureRef.current, { scale: 2, backgroundColor: '#ffffff' });
                    const link = document.createElement('a');
                    link.download = 'Comparative_Listening_Scale.png';
                    link.href = canvas.toDataURL();
                    link.click();
                } catch (err) {
                    console.error(err);
                    alert("Export failed");
                }
            };

            const scaleData = [
                { val: 10, label: "Much Easier", desc: "Significant improvement. Listening requires almost no effort compared to before.", color: "bg-emerald-100 border-emerald-300", textColor: "text-emerald-800" },
                { val: 9, label: "Very Easy", desc: "A major improvement in clarity and comfort.", color: "bg-emerald-50 border-emerald-200", textColor: "text-emerald-700" },
                { val: 8, label: "Easier", desc: "Noticeably better. Listening is clearly less straining.", color: "bg-green-50 border-green-200", textColor: "text-green-700" },
                { val: 7, label: "Moderately Easier", desc: "Definite improvement, though some effort remains.", color: "bg-lime-50 border-lime-200", textColor: "text-lime-700" },
                { val: 6, label: "Slightly Easier", desc: "A small but noticeable improvement.", color: "bg-yellow-50 border-yellow-200", textColor: "text-yellow-700" },
                { val: 5, label: "No Difference", desc: "Listening effort is exactly the same as the previous condition.", color: "bg-slate-100 border-slate-300", textColor: "text-slate-800" },
                { val: 4, label: "Slightly Harder", desc: "A small increase in difficulty or strain.", color: "bg-orange-50 border-orange-200", textColor: "text-orange-700" },
                { val: 3, label: "Moderately Harder", desc: "Noticeably more difficult to follow speech.", color: "bg-orange-100 border-orange-300", textColor: "text-orange-800" },
                { val: 2, label: "Harder", desc: "Increased strain. Listening is clearly more fatiguing.", color: "bg-red-50 border-red-200", textColor: "text-red-700" },
                { val: 1, label: "Very Hard", desc: "Much more difficult. Requires intense concentration.", color: "bg-red-100 border-red-300", textColor: "text-red-800" },
                { val: 0, label: "Much Harder", desc: "Impossible or significantly worse than before.", color: "bg-red-300 border-red-400", textColor: "text-red-900" }
            ];

            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
                    <div className="bg-white rounded-xl shadow-lg w-full max-w-lg p-6 relative max-h-[90vh] overflow-y-auto">
                        <button onClick={onClose} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><X className="w-5 h-5"/></button>
                        <div ref={captureRef} className="p-2">
                            <div className="text-center mb-6">
                                <h1 className="text-2xl font-bold text-slate-800">Comparative Listening Scale</h1>
                                <p className="text-slate-500 text-sm mt-1">...compared to the previous condition.</p>
                                <div className="flex justify-center items-center gap-4 mt-4 text-xs font-bold uppercase tracking-widest text-slate-400">
                                    <span>Harder</span>
                                    <div className="w-24 h-0.5 bg-gradient-to-r from-red-400 via-slate-300 to-emerald-400"></div>
                                    <span>Easier</span>
                                </div>
                            </div>
                            <div className="space-y-1">
                                {scaleData.map(item => (
                                    <div key={item.val} className={`flex items-center gap-4 p-3 rounded-lg border ${item.color} mb-2`}>
                                        <div className={`flex flex-col items-center justify-center w-12 h-12 bg-white/60 rounded-full font-bold text-xl shadow-sm shrink-0 ${item.textColor}`}>
                                            {item.val}
                                        </div>
                                        <div>
                                            <div className={`font-bold text-base ${item.textColor}`}>{item.label}</div>
                                            <div className="text-xs opacity-80 text-slate-600">{item.desc}</div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                        <div className="mt-4 flex justify-center gap-3">
                            <button onClick={handleDownload} className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-colors shadow-sm"><Download className="w-4 h-4" /> PNG</button>
                            <button onClick={onClose} className="px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg text-sm font-medium">Close</button>
                        </div>
                    </div>
                </div>
            );
        };

        // Recovery Modal for crash recovery
        const RecoveryModal = ({ isOpen, data, onRestore, onDiscard }) => {
            if (!isOpen || !data) return null;
            const timestamp = new Date(data.timestamp);
            const timeAgo = ((Date.now() - timestamp.getTime()) / 60000).toFixed(0); // minutes ago

            return (
                <div className="fixed inset-0 bg-black/70 z-[100] flex items-center justify-center p-4">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-md p-6 relative">
                        <div className="flex items-start gap-3 mb-4">
                            <div className="bg-blue-100 p-2 rounded-lg">
                                <FileText className="w-6 h-6 text-blue-600" />
                            </div>
                            <div>
                                <h2 className="text-lg font-bold text-slate-800">Recover Unsaved Work?</h2>
                                <p className="text-sm text-slate-500 mt-1">We found unsaved data from {timeAgo} minute{timeAgo !== '1' ? 's' : ''} ago.</p>
                            </div>
                        </div>
                        
                        <div className="bg-slate-50 rounded-lg p-4 mb-4 border border-slate-200">
                            <div className="text-sm space-y-2">
                                <div className="flex justify-between">
                                    <span className="text-slate-500">Patient:</span>
                                    <span className="font-medium text-slate-800">{data.patientName || '(empty)'}</span>
                                </div>
                                <div className="flex justify-between">
                                    <span className="text-slate-500">ID:</span>
                                    <span className="font-medium text-slate-800">{data.cNumber || '(empty)'}</span>
                                </div>
                                <div className="flex justify-between">
                                    <span className="text-slate-500">Date:</span>
                                    <span className="font-medium text-slate-800">{data.testDate}</span>
                                </div>
                                <div className="flex justify-between">
                                    <span className="text-slate-500">Time saved:</span>
                                    <span className="font-medium text-slate-800">{timestamp.toLocaleTimeString()}</span>
                                </div>
                            </div>
                        </div>

                        <div className="flex gap-3">
                            <button onClick={onRestore} className="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2.5 rounded-lg font-medium transition-colors flex items-center justify-center gap-2">
                                <RotateCcw className="w-4 h-4" /> Restore
                            </button>
                            <button onClick={onDiscard} className="flex-1 bg-slate-100 hover:bg-slate-200 text-slate-700 px-4 py-2.5 rounded-lg font-medium transition-colors">
                                Discard
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const computeAgeYears = (dobStr, refDateStr) => {
            if (!dobStr || !refDateStr) return null;
            const dob = new Date(dobStr);
            const ref = new Date(refDateStr);
            if (Number.isNaN(dob.getTime()) || Number.isNaN(ref.getTime())) return null;
            let age = ref.getFullYear() - dob.getFullYear();
            const m = ref.getMonth() - dob.getMonth();
            if (m < 0 || (m === 0 && ref.getDate() < dob.getDate())) age--;
            return age >= 0 ? age : null;
        };

        const App = () => {
            // ... (State setup) ...
            const [firstName, setFirstName] = useState('');
            const [lastName, setLastName] = useState('');
            const patientName = `${firstName.trim()}${lastName.trim() ? ' ' + lastName.trim() : ''}`.trim();
            const [cNumber, setCNumber] = useState('');
            const [dateOfBirth, setDateOfBirth] = useState('');
            const [testDate, setTestDate] = useState(new Date().toISOString().split('T')[0]);
            const [activeTab, setActiveTab] = useState('scoring');
            const [activeTestId, setActiveTestId] = useState('A');
            const [confidenceLevel, setConfidenceLevel] = useState(80);
            const [clearConfirm, setClearConfirm] = useState(false);
            const [showScaleModal, setShowScaleModal] = useState(false);
            const [showChartModal, setShowChartModal] = useState(false);
            const [showPhonemeModal, setShowPhonemeModal] = useState(false);
            const [showLoadModal, setShowLoadModal] = useState(false);
            const [currentTestId, setCurrentTestId] = useState(null);
            const [showComparativeScaleModal, setShowComparativeScaleModal] = useState(false); // NEW STATE

            // New State for Settings
            const [showSettingsModal, setShowSettingsModal] = useState(false);
            const [clinicSettings, setClinicSettings] = useState(null);

            // Auth/Encryption State
            const [isLocked, setIsLocked] = useState(true);
            const [hasPassword, setHasPassword] = useState(false);
            const [dbReady, setDbReady] = useState(false);

            // --- AUTH INIT & SETTINGS LOAD ---
            useEffect(() => {
                const init = async () => {
                    const isSetup = await window.SecureDB.isSetup();
                    setHasPassword(isSetup);
                    setDbReady(true);
                };
                init();
            }, []);

            // Load settings after unlock
            useEffect(() => {
                if (!isLocked) {
                    window.SecureDB.getSettings().then(s => setClinicSettings(s));
                }
            }, [isLocked]);

            const fileInputRef = useRef(null);
            const saveHandlerRef = useRef(null);
            const [importModePick, setImportModePick] = useState('append');
            const [showImportPreviewModal, setShowImportPreviewModal] = useState(false);
            const [importPreviewRecords, setImportPreviewRecords] = useState([]);
            const [importPreviewFileName, setImportPreviewFileName] = useState('');
            const [importPreviewInvalidCount, setImportPreviewInvalidCount] = useState(0);
            const [showImportSourceModal, setShowImportSourceModal] = useState(false);

            const [showDeleteDbModal, setShowDeleteDbModal] = useState(false);
            const [deleteDbConfirmText, setDeleteDbConfirmText] = useState('');
            const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
            const [showRecoveryModal, setShowRecoveryModal] = useState(false);
            const [recoveryData, setRecoveryData] = useState(null);
            const [lastSaved, setLastSaved] = useState(null);
            const [autoSaveEnabled, setAutoSaveEnabled] = useState(true);
            const [showExportModal, setShowExportModal] = useState(false);
            const [showEncryptedImportModal, setShowEncryptedImportModal] = useState(false);
            const [encryptedImportPassword, setEncryptedImportPassword] = useState('');
            const [encryptedImportFile, setEncryptedImportFile] = useState(null);

            const [tests, setTests] = useState({
                A: { id: 'A', listId: '3A', section: 'second_10', scoringMode: 'word', condition: 'Unaided', deviceModel: '', level: '', snr: '', scores: {}, limitTo10: false, askedContinue: false },
                B: { id: 'B', listId: '4A', section: 'second_10', scoringMode: 'word', condition: 'New Tech', deviceModel: '', level: '', snr: '', scores: {}, limitTo10: false, askedContinue: false },
                comparativeEase: 5
            });

            // ... (Helper memos: activeTest, statsA, statsB, limits ...) ...
            const activeTest = tests[activeTestId];
            const statsA = useMemo(() => calculateStats(tests.A.listId, tests.A.section, tests.A.scores, tests.A.limitTo10), [tests.A]);
            const statsB = useMemo(() => calculateStats(tests.B.listId, tests.B.section, tests.B.scores, tests.B.limitTo10), [tests.B]);
            const activeStats = activeTestId === 'A' ? statsA : statsB;
            const ageYears = useMemo(() => computeAgeYears(dateOfBirth, testDate), [dateOfBirth, testDate]);
            const wordCriticalLimits = useMemo(() => { if (statsA.totalWords === 0) return { lower: 0, upper: 100 }; return getCriticalLimits(statsA.wordPercent, statsA.totalWords, confidenceLevel); }, [statsA.wordPercent, statsA.totalWords, confidenceLevel]);
            const phonemeCriticalLimits = useMemo(() => { 
                if (statsA.totalPhonemes === 0) return { lower: 0, upper: 100 }; 
                // CRITICAL FIX: Use unrounded percentage for table lookup
                const rawPercent = (statsA.correctPhonemes / statsA.totalPhonemes) * 100;
                return getCriticalLimits(rawPercent, statsA.totalPhonemes, confidenceLevel, true); 
            }, [statsA.correctPhonemes, statsA.totalPhonemes, confidenceLevel]);
            const isWordDiffSig = statsB.wordPercent < wordCriticalLimits.lower || statsB.wordPercent > wordCriticalLimits.upper;
            const isPhonemeDiffSig = statsB.phonemePercent < phonemeCriticalLimits.lower || statsB.phonemePercent > phonemeCriticalLimits.upper;
            const getSectionOptions = (testId) => { 
                const test = tests[testId];
                // HF1 and HF2 lists only support full (1-25)
                if (test.listId === 'HF1' || test.listId === 'HF2') {
                    return [ { val: 'full', label: 'Full List (1-25)', n: 25 } ];
                }
                const options = [ { val: 'first_10', label: '1st Half (First 10)', n: 10 }, { val: 'first', label: '1st Half (1-25)', n: 25 }, { val: 'second_10', label: '2nd Half (First 10)', n: 10 }, { val: 'second', label: '2nd Half (26-50)', n: 25 }, { val: 'full', label: 'Full List (1-50)', n: 50 } ]; 
                if (testId === 'A') return options; 
                const aSection = tests.A.section; 
                const aIsTen = aSection.includes('_10'); 
                const aIsHalf = aSection === 'first' || aSection === 'second'; 
                const aIsFull = aSection === 'full'; 
                return options.filter(opt => { if (aIsTen) return opt.n === 10; if (aIsHalf) return opt.n === 25; if (aIsFull) return opt.n === 50; return true; }); 
            };

            // ... (Update/Toggle handlers) ...
            const updateActiveTest = (field, value) => { 
                if (field === 'scoringMode' && value === 'phoneme') setShowPhonemeModal(true); 
                setHasUnsavedChanges(true); 
                setTests(prev => { 
                    const newTests = { ...prev, [activeTestId]: { ...prev[activeTestId], [field]: value } }; 
                    
                    // If changing to HF1 or HF2 list, force section to 'full'
                    if (field === 'listId' && (value === 'HF1' || value === 'HF2')) {
                        newTests[activeTestId].section = 'full';
                    }
                    
                    if (activeTestId === 'A' && field === 'section') { 
                        const isTen = value.includes('_10'); 
                        const isHalf = value === 'first' || value === 'second'; 
                        const isFull = value === 'full'; 
                        let bSection = newTests.B.section; 
                        if (isTen) { if (!bSection.includes('_10')) bSection = 'first_10'; } 
                        else if (isHalf) { if (bSection !== 'first' && bSection !== 'second') bSection = 'first'; } 
                        else if (isFull) { bSection = 'full'; } 
                        newTests.B.section = bSection; 
                    } 
                    if (field === 'scoringMode') { 
                        newTests.A.scoringMode = value; 
                        newTests.B.scoringMode = value; 
                    } 
                    if (activeTestId === 'A' && (field === 'level' || field === 'snr')) { 
                        newTests.B[field] = value; 
                    } 
                    return newTests; 
                }); 
            };
            const updateComparativeEase = (value) => { setHasUnsavedChanges(true); setTests(prev => ({ ...prev, comparativeEase: value })); };
            const togglePhoneme = (wordIndex, pIndex) => { setHasUnsavedChanges(true); const listId = activeTest.listId; const key = `${listId}_${wordIndex}_${pIndex}`; setTests(prev => { const currentScores = prev[activeTestId].scores; const newScores = { ...currentScores, [key]: !currentScores[key] }; return { ...prev, [activeTestId]: { ...prev[activeTestId], scores: newScores } }; }); };
            const setWordScore = (wordIndex, isCorrect) => { setHasUnsavedChanges(true); const listId = activeTest.listId; const wordData = activeStats.visibleWords.find(w => w.i === wordIndex); if (!wordData) return; setTests(prev => { const currentScores = { ...prev[activeTestId].scores }; let shouldClear = false; let currentIsAllCorrect = true; let currentIsAllIncorrect = true; let hasAnyScore = false; wordData.p.forEach((p, idx) => { if (p !== '-') { const val = currentScores[`${listId}_${wordIndex}_${idx}`]; if (val !== undefined) hasAnyScore = true; if (val !== true) currentIsAllCorrect = false; if (val !== false) currentIsAllIncorrect = false; } }); if (isCorrect && currentIsAllCorrect && hasAnyScore) shouldClear = true; if (!isCorrect && currentIsAllIncorrect && hasAnyScore) shouldClear = true; wordData.p.forEach((p, idx) => { if (p !== '-') { if (shouldClear) { delete currentScores[`${listId}_${wordIndex}_${idx}`]; } else { currentScores[`${listId}_${wordIndex}_${idx}`] = isCorrect; } } }); return { ...prev, [activeTestId]: { ...prev[activeTestId], scores: currentScores } }; }); };
            const toggleWordCorrect = (wordIndex) => { setHasUnsavedChanges(true); const listId = activeTest.listId; const wordData = activeStats.visibleWords.find(w => w.i === wordIndex); if (!wordData) return; setTests(prev => { const currentScores = { ...prev[activeTestId].scores }; let isFullyCorrect = true; wordData.p.forEach((p, idx) => { if (p !== '-' && !currentScores[`${listId}_${wordIndex}_${idx}`]) { isFullyCorrect = false; } }); wordData.p.forEach((p, idx) => { if (p !== '-') { if (isFullyCorrect) { delete currentScores[`${listId}_${wordIndex}_${idx}`]; } else { currentScores[`${listId}_${wordIndex}_${idx}`] = true; } } }); return { ...prev, [activeTestId]: { ...prev[activeTestId], scores: currentScores } }; }); };
            const markAll = (correct) => { setHasUnsavedChanges(true); const listData = activeStats.visibleWords; const listId = activeTest.listId; setTests(prev => { const newScores = { ...prev[activeTestId].scores }; listData.forEach(word => { word.p.forEach((phoneme, pIndex) => { if (phoneme === '-') return; const key = `${listId}_${word.i}_${pIndex}`; if(correct) newScores[key] = true; else delete newScores[key]; }); }); return { ...prev, [activeTestId]: { ...prev[activeTestId], scores: newScores, askedContinue: true } }; }); };

            const resetForm = () => {
                setCurrentTestId(null);
                setFirstName('');
                setLastName('');
                setCNumber('');
                setDateOfBirth('');
                setTestDate(new Date().toISOString().split('T')[0]);
                setTests({
                    A: { id: 'A', listId: '3A', section: 'second_10', scoringMode: 'word', condition: 'Unaided', deviceModel: '', level: '', snr: '', scores: {}, limitTo10: false, askedContinue: false },
                    B: { id: 'B', listId: '4A', section: 'second_10', scoringMode: 'word', condition: 'New Tech', deviceModel: '', level: '', snr: '', scores: {}, limitTo10: false, askedContinue: false },
                    comparativeEase: 5
                });
                setActiveTestId('A');
                setActiveTab('scoring');
                setClearConfirm(false);
                setHasUnsavedChanges(false);
                localStorage.removeItem('nu6_draft_recovery');
            };

            const handleSave = async () => {
                if (!patientName.trim()) { alert("Please enter a Patient Name."); return; }
                if (!testDate) { alert("Please set a Test Date before saving."); return; }
                const data = { id: currentTestId, patientName, cNumber, dateOfBirth, testDate, tests, activeTestId, activeTab, confidenceLevel };
                try {
                    try {
                        const savedId = await window.SecureDB.saveTest(data);
                        setCurrentTestId(savedId);
                        setHasUnsavedChanges(false);
                        setLastSaved(new Date());
                        localStorage.removeItem('nu6_draft_recovery');
                        alert("Test encrypted and saved to local database successfully!");
                    } catch (e) {
                        if (e && e.code === 'DUPLICATE_DATE') {
                            // Prompt user to overwrite existing same-date record
                            if (confirm('A different test exists for this patient on the same date. Overwrite it?')) {
                                const savedId = await window.SecureDB.saveTest(data, { overwriteExistingSameDate: true });
                                setCurrentTestId(savedId);
                                setHasUnsavedChanges(false);
                                setLastSaved(new Date());
                                localStorage.removeItem('nu6_draft_recovery');
                                alert('Existing record overwritten and saved successfully.');
                            } else {
                                // User cancelled - do nothing
                                return;
                            }
                        } else {
                            throw e;
                        }
                    }
                } catch (e) {
                    console.error('Save error', e);
                    alert('Failed to save to local database. ' + (e && e.message ? e.message : ''));
                }
            };
            
            const handleAutoSave = async () => {
                if (!patientName.trim() || !testDate || !hasUnsavedChanges) return;
                const data = { id: currentTestId, patientName, cNumber, dateOfBirth, testDate, tests, activeTestId, activeTab, confidenceLevel };
                try {
                    const savedId = await window.SecureDB.saveTest(data, currentTestId ? { overwriteExistingSameDate: true } : {});
                    setCurrentTestId(savedId);
                    setHasUnsavedChanges(false);
                    setLastSaved(new Date());
                    localStorage.removeItem('nu6_draft_recovery');
                } catch (e) {
                    console.error('Auto-save error', e);
                    // Silent failure for auto-save - don't interrupt user
                }
            };
            
            const handleLoadTest = (loadedData) => { if (loadedData) { setCurrentTestId(loadedData.id);
                    // Populate first/last name from explicit fields if present, otherwise split existing patientName
                    let lf = '';
                    let ll = '';
                    if (loadedData.firstName !== undefined || loadedData.lastName !== undefined) {
                        lf = loadedData.firstName || '';
                        ll = loadedData.lastName || '';
                    } else if (loadedData.patientName) {
                        const parts = (loadedData.patientName || '').trim().split(/\s+/);
                        lf = parts.shift() || '';
                        ll = parts.join(' ') || '';
                    }
                    setFirstName(lf);
                    setLastName(ll);
                    setCNumber(loadedData.cNumber || ''); setDateOfBirth(loadedData.dateOfBirth || ''); setTestDate(loadedData.testDate || new Date().toISOString().split('T')[0]); setTests(loadedData.tests); setActiveTestId(loadedData.activeTestId || 'A'); setActiveTab(loadedData.activeTab || 'scoring'); if(loadedData.confidenceLevel) setConfidenceLevel(loadedData.confidenceLevel); setHasUnsavedChanges(false); } };
            const handleDeleteCurrentRecord = async () => { if (!currentTestId) return; if (confirm("Are you sure you want to delete this record from the database?")) { try { await window.SecureDB.deleteTest(currentTestId); alert("Record deleted."); resetForm(); } catch (e) { console.error(e); alert("Failed to delete record."); } } };

            const handleDeleteAllDb = async () => {
                if (!confirm('This will permanently remove ALL patient records from the local database but will preserve clinic settings. Continue?')) return;
                try {
                    await window.SecureDB.deleteAllTests();
                    alert('Database cleared. Clinic settings preserved.');
                    resetForm();
                } catch (e) {
                    console.error('Failed to delete database:', e);
                    alert('Failed to delete database.');
                }
            };
            // Open export modal to choose export type
            const handleExportDB = () => {
                setShowExportModal(true);
            };

            // Export encrypted with password (AES-256)
            const handleExportEncrypted = async () => {
                try {
                    const allData = await window.SecureDB.getAllTests();
                    const password = prompt('Enter a password to encrypt the export file (remember this password - you\'ll need it to import):');
                    if (!password) { alert('Export cancelled - no password provided.'); return; }
                    if (password.length < 8) { alert('Password must be at least 8 characters.'); return; }
                    
                    // Encrypt entire dataset
                    const encrypted = await CryptoService.encryptData(allData, password);
                    const exportObj = { version: '1.0', encrypted: true, data: encrypted };
                    const jsonString = JSON.stringify(exportObj, null, 2);
                    const blob = new Blob([jsonString], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `NU6_Encrypted_Export_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    setShowExportModal(false);
                    alert('Encrypted export complete. Keep your password safe!');
                } catch (err) {
                    console.error('Encrypted export failed:', err);
                    alert('Failed to export encrypted database.');
                }
            };

            // Export de-identified (remove PHI)
            const handleExportDeidentified = async () => {
                try {
                    const allData = await window.SecureDB.getAllTests();
                    const deidentified = allData.map(record => {
                        const { patientName, dateOfBirth, ...rest } = record;
                        let age = null;
                        if (dateOfBirth && record.testDate) {
                            age = computeAgeYears(dateOfBirth, record.testDate);
                        }
                        return {
                            ...rest,
                            patientName: '[REDACTED]',
                            dateOfBirth: null,
                            age: age !== null && age >= 90 ? '90+' : age
                        };
                    });
                    const jsonString = JSON.stringify(deidentified, null, 2);
                    const blob = new Blob([jsonString], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `NU6_Deidentified_Export_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    setShowExportModal(false);
                    alert('De-identified export complete (PHI removed).');
                } catch (err) {
                    console.error('De-identified export failed:', err);
                    alert('Failed to export de-identified database.');
                }
            };

            // Import DB: open source selection (simulated or upload)
            const handleImportDB = () => {
                setShowImportSourceModal(true);
            };

            // Choose to use simulated DB
            const handleUseSimulatedDB = () => {
                setImportPreviewRecords(SIMULATED_DB);
                setImportPreviewFileName('SIMULATED_DB.json');
                const invalidCount = SIMULATED_DB.filter(r => !r || !r.patientName || !r.testDate || !r.tests).length;
                setImportPreviewInvalidCount(invalidCount);
                setShowImportSourceModal(false);
                setShowImportPreviewModal(true);
            };

            // Choose to upload a file
            const handleUseFileUpload = () => {
                setShowImportSourceModal(false);
                if (fileInputRef && fileInputRef.current) fileInputRef.current.click();
            };

            // Handle the selected JSON file and show import preview
            const handleImportFile = async (e) => {
                const file = e?.target?.files?.[0];
                if (!file) return;
                try {
                    const text = await file.text();
                    let parsed = JSON.parse(text);
                    
                    // Check if this is an encrypted export
                    if (parsed && parsed.encrypted === true && parsed.data) {
                        setEncryptedImportFile(parsed.data);
                        setShowEncryptedImportModal(true);
                        if (e && e.target) e.target.value = '';
                        return;
                    }
                    
                    let records = [];
                    if (Array.isArray(parsed)) {
                        records = parsed;
                    } else if (parsed && parsed.entry && Array.isArray(parsed.entry)) {
                        // If some other bundle shape (e.g., FHIR-like), attempt to extract resources
                        records = parsed.entry.map(en => en.resource || en);
                    } else if (parsed && parsed.tests) {
                        records = [parsed];
                    } else {
                        alert("Invalid JSON format. Expected an array of test records exported from this app.");
                        if (e && e.target) {
                            e.target.value = '';
                        }
                        return;
                    }

                    if (records.length === 0) {
                        alert("No records found in file.");
                        if (e && e.target) {
                            e.target.value = '';
                        }
                        return;
                    }

                    const invalidCount = records.filter(r => !r || !r.patientName || !r.testDate || !r.tests).length;

                    // Set preview state and open modal
                    setImportPreviewRecords(records);
                    setImportPreviewFileName(file.name);
                    setImportPreviewInvalidCount(invalidCount);
                    setShowImportPreviewModal(true);

                } catch (err) {
                    console.error(err);
                    alert('Failed to parse file: ' + (err && err.message ? err.message : err));
                    if (e && e.target) {
                        e.target.value = '';
                    }
                }
            };

            // Perform the actual import (called by modal confirm actions)
            const mergeTestSections = (existing = {}, incoming = {}) => {
                return {
                    ...existing,
                    ...incoming,
                    scores: { ...(existing.scores || {}), ...(incoming.scores || {}) }
                };
            };

            const mergeRecordsById = (existing = {}, incoming = {}) => {
                const existingTests = existing.tests || {};
                const incomingTests = incoming.tests || {};
                const mergedTests = {
                    ...existingTests,
                    ...incomingTests,
                    A: mergeTestSections(existingTests.A || {}, incomingTests.A || {}),
                    B: mergeTestSections(existingTests.B || {}, incomingTests.B || {}),
                    comparativeEase: incomingTests.comparativeEase ?? existingTests.comparativeEase
                };

                return {
                    ...existing,
                    ...incoming,
                    id: existing.id || incoming.id,
                    patientName: incoming.patientName || existing.patientName || '',
                    cNumber: incoming.cNumber || existing.cNumber || '',
                    dateOfBirth: incoming.dateOfBirth || existing.dateOfBirth || '',
                    testDate: incoming.testDate || existing.testDate || '',
                    tests: mergedTests,
                    activeTestId: incoming.activeTestId ?? existing.activeTestId,
                    activeTab: incoming.activeTab ?? existing.activeTab,
                    confidenceLevel: incoming.confidenceLevel ?? existing.confidenceLevel
                };
            };

            const importRecords = async (mode) => {
                // mode: 'overwrite' | 'append' | 'skip' | 'merge'
                setShowImportPreviewModal(false);
                const records = importPreviewRecords || [];
                let imported = 0; let errors = 0; let skipped = 0;

                // Build existing maps for IDs and patient|date
                let existingIds = new Set();
                let existingById = new Map();
                let existingByPatientDate = new Map();
                try {
                    const existing = await window.SecureDB.getAllTests();
                    existingIds = new Set(existing.map(r => r.id));
                    existingById = new Map(existing.map(r => [r.id, r]));
                    for (const r of existing) {
                        const key = `${r.cNumber || r.patientName}||${r.testDate}`;
                        if (!existingByPatientDate.has(key)) existingByPatientDate.set(key, r.id);
                    }
                } catch (e) { console.error('Failed to fetch existing records for import checks', e); }

                for (const rec of records) {
                    try {
                        if (!rec) { errors++; continue; }
                        const recKey = `${rec.cNumber || rec.patientName}||${rec.testDate}`;
                        const existingIdForKey = existingByPatientDate.get(recKey);

                        // Skip duplicates by ID when mode=skip
                        if (mode === 'skip' && rec && rec.id && existingIds.has(rec.id)) {
                            skipped++;
                            continue;
                        }

                        if (mode === 'merge') {
                            if (rec.id && existingById.has(rec.id)) {
                                const merged = mergeRecordsById(existingById.get(rec.id), rec);
                                await window.SecureDB.saveTest(merged);
                                existingIds.add(rec.id);
                                existingById.set(rec.id, merged);
                                existingByPatientDate.set(recKey, rec.id);
                                imported++;
                                continue;
                            }

                            if (existingIdForKey && existingById.has(existingIdForKey)) {
                                const merged = mergeRecordsById(existingById.get(existingIdForKey), { ...rec, id: existingIdForKey });
                                await window.SecureDB.saveTest(merged);
                                existingIds.add(existingIdForKey);
                                existingById.set(existingIdForKey, merged);
                                existingByPatientDate.set(recKey, existingIdForKey);
                                imported++;
                                continue;
                            }

                            const savedId = await window.SecureDB.saveTest(rec);
                            const finalId = rec.id || savedId;
                            existingIds.add(finalId);
                            existingById.set(finalId, { ...rec, id: finalId });
                            existingByPatientDate.set(recKey, finalId);
                            imported++;
                            continue;
                        }

                        if (mode === 'append') {
                            // Do not append if same patient/date already exists
                            if (existingByPatientDate.has(recKey)) { skipped++; continue; }
                            const toSave = { ...rec };
                            delete toSave.id; // create new id
                            // default save will block same-date duplicates, but we pre-checked
                            const savedId = await window.SecureDB.saveTest(toSave);
                            const finalId = savedId || toSave.id;
                            existingIds.add(finalId);
                            existingById.set(finalId, { ...toSave, id: finalId });
                            existingByPatientDate.set(recKey, finalId);
                            imported++;
                        } else if (mode === 'overwrite') {
                            // Overwrite by ID if present, else overwrite any same patient/date
                            if (rec.id && existingIds.has(rec.id)) {
                                await window.SecureDB.saveTest(rec); // will overwrite because same id
                                existingIds.add(rec.id);
                                existingById.set(rec.id, rec);
                                existingByPatientDate.set(recKey, rec.id);
                                imported++;
                            } else if (existingByPatientDate.has(recKey)) {
                                // delete existing by patient/date and save incoming record (preserve its id)
                                const existingId = existingByPatientDate.get(recKey);
                                try { await window.SecureDB.deleteTest(existingId); } catch (e) { console.warn('Failed to delete existing by date', e); }
                                await window.SecureDB.saveTest(rec);
                                const finalId = rec.id || existingId;
                                existingIds.add(finalId);
                                existingById.set(finalId, { ...rec, id: finalId });
                                existingByPatientDate.set(recKey, finalId);
                                imported++;
                            } else {
                                // no match - just save
                                const savedId = await window.SecureDB.saveTest(rec);
                                const finalId = rec.id || savedId;
                                existingIds.add(finalId);
                                existingById.set(finalId, { ...rec, id: finalId });
                                existingByPatientDate.set(recKey, finalId);
                                imported++;
                            }
                        } else {
                            // fallback - treat as append
                            const toSave = { ...rec };
                            delete toSave.id;
                            const savedId = await window.SecureDB.saveTest(toSave);
                            const finalId = savedId || toSave.id;
                            existingIds.add(finalId);
                            existingById.set(finalId, { ...toSave, id: finalId });
                            existingByPatientDate.set(recKey, finalId);
                            imported++;
                        }
                    } catch (err) {
                        console.error('Import failed for record', rec, err);
                        errors++;
                    }
                }
                
                // Reset file input after a short delay to avoid Windows focus issues
                setTimeout(() => {
                    if (fileInputRef && fileInputRef.current) {
                        fileInputRef.current.value = '';
                    }
                }, 100);
                setImportPreviewRecords([]);
                setImportPreviewFileName('');
                setImportPreviewInvalidCount(0);
                alert(`Import complete. ${imported} records imported, ${skipped} skipped, ${errors} errors.`);
            };

            const handleOpenClick = () => fileInputRef.current.click(); // Unused
            const clearAllData = () => { if (clearConfirm) { if (hasUnsavedChanges && !confirm('You have unsaved changes. Continue without saving?')) { setClearConfirm(false); return; } resetForm(); } else { setClearConfirm(true); setTimeout(() => setClearConfirm(false), 3000); } };

            // Track unsaved changes and expose to Electron main process
            useEffect(() => {
                // Expose state to main process for close event handling
                window.hasUnsavedChanges = hasUnsavedChanges;
                
                // Update ref with current save handler
                saveHandlerRef.current = handleSave;
                
                // Expose save function via ref to avoid dependency issues
                window.saveBeforeClose = () => {
                    if (saveHandlerRef.current) {
                        return saveHandlerRef.current();
                    }
                };
            }, [hasUnsavedChanges]);

            // Auto-save draft every 10 seconds when there are unsaved changes
            useEffect(() => {
                if (!hasUnsavedChanges || isLocked) return;
                
                const saveDraft = () => {
                    try {
                        const draft = {
                            timestamp: new Date().toISOString(),
                            patientName,
                            cNumber,
                            dateOfBirth,
                            testDate,
                            tests,
                            activeTestId,
                            activeTab,
                            confidenceLevel,
                            currentTestId
                        };
                        localStorage.setItem('nu6_draft_recovery', JSON.stringify(draft));
                    } catch (e) {
                        console.error('Failed to save draft:', e);
                    }
                };

                const timer = setInterval(saveDraft, 10000); // Auto-save every 10 seconds
                return () => clearInterval(timer);
            }, [hasUnsavedChanges, patientName, cNumber, dateOfBirth, testDate, tests, activeTestId, activeTab, confidenceLevel, currentTestId, isLocked]);

            // Check for recovery data on mount (after unlock)
            useEffect(() => {
                if (isLocked) return;
                try {
                    const draft = localStorage.getItem('nu6_draft_recovery');
                    if (draft) {
                        const parsed = JSON.parse(draft);
                        // Only offer recovery if draft is less than 24 hours old
                        const draftTime = new Date(parsed.timestamp);
                        const hoursSince = (Date.now() - draftTime.getTime()) / (1000 * 60 * 60);
                        if (hoursSince < 24) {
                            setRecoveryData(parsed);
                            setShowRecoveryModal(true);
                        } else {
                            // Clear old draft
                            localStorage.removeItem('nu6_draft_recovery');
                        }
                    }
                } catch (e) {
                    console.error('Failed to check recovery data:', e);
                }
            }, [isLocked]);
            
            // Auto-save every 30 seconds
            useEffect(() => {
                if (!autoSaveEnabled || isLocked) return;
                
                const interval = setInterval(() => {
                    if (hasUnsavedChanges) {
                        handleAutoSave();
                    }
                }, 30000); // 30 seconds
                
                return () => clearInterval(interval);
            }, [hasUnsavedChanges, autoSaveEnabled, isLocked, patientName, testDate, currentTestId, cNumber, dateOfBirth, tests, activeTestId, activeTab, confidenceLevel]);

            const handleRestoreRecovery = () => {
                if (!recoveryData) return;
                setCurrentTestId(recoveryData.currentTestId);
                // Restore first/last name from recovery if available
                if (recoveryData.firstName !== undefined || recoveryData.lastName !== undefined) {
                    setFirstName(recoveryData.firstName || '');
                    setLastName(recoveryData.lastName || '');
                } else {
                    const parts = (recoveryData.patientName || '').trim().split(/\s+/);
                    setFirstName(parts.shift() || '');
                    setLastName(parts.join(' ') || '');
                }
                setCNumber(recoveryData.cNumber || '');
                setDateOfBirth(recoveryData.dateOfBirth || '');
                setTestDate(recoveryData.testDate || new Date().toISOString().split('T')[0]);
                setTests(recoveryData.tests);
                setActiveTestId(recoveryData.activeTestId || 'A');
                setActiveTab(recoveryData.activeTab || 'scoring');
                setConfidenceLevel(recoveryData.confidenceLevel || 95);
                setHasUnsavedChanges(true); // Mark as unsaved so they can save it
                setShowRecoveryModal(false);
                setRecoveryData(null);
            };

            const handleDiscardRecovery = () => {
                localStorage.removeItem('nu6_draft_recovery');
                setShowRecoveryModal(false);
                setRecoveryData(null);
            };

            // Handle encrypted import with password
            const handleDecryptAndImport = async () => {
                if (!encryptedImportPassword || !encryptedImportFile) {
                    alert('Please enter the password.');
                    return;
                }
                try {
                    const decrypted = await CryptoService.decryptData(encryptedImportFile, encryptedImportPassword);
                    if (!Array.isArray(decrypted)) {
                        alert('Invalid encrypted file format.');
                        return;
                    }
                    // Show import preview
                    setImportPreviewRecords(decrypted);
                    setImportPreviewFileName('Encrypted Import');
                    const invalidCount = decrypted.filter(r => !r || !r.patientName || !r.testDate || !r.tests).length;
                    setImportPreviewInvalidCount(invalidCount);
                    setShowEncryptedImportModal(false);
                    setEncryptedImportPassword('');
                    setEncryptedImportFile(null);
                    setShowImportPreviewModal(true);
                } catch (err) {
                    console.error('Decryption failed:', err);
                    alert('Failed to decrypt file. Wrong password or corrupted file.');
                }
            };

            const handleSaveSettings = async (newSettings) => {
                try {
                    await window.SecureDB.saveSettings(newSettings);
                    setClinicSettings(newSettings);
                    alert("Settings saved successfully.");
                } catch(e) { console.error(e); alert("Failed to save settings."); }
            };

            const handleExportPDF = () => {
                const doc = new window.jspdf.jsPDF();

                // Format Condition Helper
                const formatCondition = (test) => test.deviceModel ? `${test.condition}\n(${test.deviceModel})` : test.condition;

                // Header (Clinic Info)
                doc.setFontSize(18);
                doc.text("NU-6 Speech Recognition Report", 105, 20, { align: 'center' });

                doc.setFontSize(12);
                if (clinicSettings) {
                    doc.text(clinicSettings.clinicName || "", 20, 30);
                    doc.setFontSize(10);
                    doc.text(`Audiologist: ${clinicSettings.audiologistName || ""}`, 20, 36);
                    doc.text(`License: ${clinicSettings.licenseNumber || ""}`, 20, 42);
                }

                // Patient Info
                doc.setFontSize(12);
                const reportAge = computeAgeYears(dateOfBirth, testDate);
                doc.text(`Patient: ${patientName}`, 140, 30);
                doc.text(`ID: ${cNumber}`, 140, 36);
                doc.text(`Date: ${testDate}`, 140, 42);
                doc.text(`DOB: ${dateOfBirth || '--'}`, 140, 48);
                doc.text(`Age: ${reportAge !== null && reportAge !== undefined ? reportAge + ' yrs' : '--'}`, 140, 54);

                doc.line(20, 58, 190, 58);

                // Summary Table
                doc.autoTable({
                    startY: 62,
                    head: [['Test', 'Condition', 'List', 'Level', 'SNR', 'Word Score', 'Phoneme Score']],
                    body: [
                        ['Test A', formatCondition(tests.A), tests.A.listId, `${tests.A.level || '--'}`, `${tests.A.snr || '--'}`, `${statsA.wordPercent}%`, `${statsA.phonemePercent}%`],
                        ['Test B', formatCondition(tests.B), tests.B.listId, `${tests.B.level || '--'}`, `${tests.B.snr || '--'}`, `${statsB.wordPercent}%`, `${statsB.phonemePercent}%`]
                    ],
                    theme: 'striped',
                    headStyles: { fillColor: [66, 135, 245] }
                });

                // Significance
                let finalY = doc.lastAutoTable.finalY + 10;
                doc.setFontSize(11);
                doc.text("Statistical Significance:", 20, finalY);
                finalY += 6;
                doc.setFontSize(10);
                doc.text(`Critical Difference Level: ${confidenceLevel}%`, 20, finalY);
                finalY += 5;
                const isSig = isWordDiffSig ? "YES - Significant Difference" : "NO - Within Critical Limits";
                doc.text(`Word Score Difference: ${isSig}`, 20, finalY);

                // Add Phoneme Significance to PDF if applicable
                if (tests.A.scoringMode === 'phoneme' && tests.B.scoringMode === 'phoneme') {
                    finalY += 5;
                    const isPhonSig = isPhonemeDiffSig ? "YES - Significant Difference" : "NO - Within Critical Limits";
                    doc.text(`Phoneme Score Difference: ${isPhonSig}`, 20, finalY);
                    
                    // Add Error Pattern Analysis for phoneme scoring
                    finalY += 10;
                    doc.setFontSize(11);
                    doc.text("Error Pattern Analysis:", 20, finalY);
                    doc.setFontSize(10);
                    
                    // Calculate manner, place, and voicing errors for both tests
                    const calculateFeatureErrors = (test) => {
                        const listData = getListData(test.listId);
                        let visibleWords = listData;
                        if (test.section === 'first') visibleWords = listData.slice(0, 25);
                        else if (test.section === 'first_10') visibleWords = listData.slice(0, 10);
                        else if (test.section === 'second') visibleWords = listData.slice(25, 50);
                        else if (test.section === 'second_10') visibleWords = listData.slice(25, 35);
                        if (test.limitTo10) visibleWords = visibleWords.slice(0, 10);
                        
                        const mannerErrors = {}, placeErrors = {}, voicingErrors = { Voiced: { total: 0, missed: 0 }, Voiceless: { total: 0, missed: 0 } };
                        
                        visibleWords.forEach(word => {
                            word.p.forEach((p, idx) => {
                                if (p === '-') return;
                                const isCorrect = test.scores[`${test.listId}_${word.i}_${idx}`];
                                const features = PHONEME_FEATURES[p];
                                
                                if (features) {
                                    const { manner, place, voicing } = features;
                                    if (manner) {
                                        if (!mannerErrors[manner]) mannerErrors[manner] = { total: 0, missed: 0 };
                                        mannerErrors[manner].total++;
                                        if (!isCorrect) mannerErrors[manner].missed++;
                                    }
                                    if (place) {
                                        if (!placeErrors[place]) placeErrors[place] = { total: 0, missed: 0 };
                                        placeErrors[place].total++;
                                        if (!isCorrect) placeErrors[place].missed++;
                                    }
                                    if (voicing) {
                                        voicingErrors[voicing].total++;
                                        if (!isCorrect) voicingErrors[voicing].missed++;
                                    }
                                }
                            });
                        });
                        
                        // Calculate totals
                        let totalManner = 0, missedManner = 0, totalPlace = 0, missedPlace = 0, totalVoicing = 0, missedVoicing = 0;
                        Object.values(mannerErrors).forEach(data => { totalManner += data.total; missedManner += data.missed; });
                        Object.values(placeErrors).forEach(data => { totalPlace += data.total; missedPlace += data.missed; });
                        Object.values(voicingErrors).forEach(data => { totalVoicing += data.total; missedVoicing += data.missed; });
                        
                        return {
                            manner: totalManner > 0 ? Math.round((missedManner / totalManner) * 100) : 0,
                            place: totalPlace > 0 ? Math.round((missedPlace / totalPlace) * 100) : 0,
                            voicing: totalVoicing > 0 ? Math.round((missedVoicing / totalVoicing) * 100) : 0
                        };
                    };
                    
                    const errorsA = calculateFeatureErrors(tests.A);
                    const errorsB = calculateFeatureErrors(tests.B);
                    
                    finalY += 6;
                    doc.text(`Test A - Manner: ${errorsA.manner}%  |  Place: ${errorsA.place}%  |  Voicing: ${errorsA.voicing}%`, 25, finalY);
                    finalY += 5;
                    doc.text(`Test B - Manner: ${errorsB.manner}%  |  Place: ${errorsB.place}%  |  Voicing: ${errorsB.voicing}%`, 25, finalY);
                }

                // Add Comparative Ease if applicable
                if (!isWordDiffSig && !(tests.A.scoringMode === 'phoneme' && isPhonemeDiffSig)) {
                    finalY += 5;
                    const ratingText = `Comparative Ease of Listening Rating: ${tests.comparativeEase}/10`;
                    doc.text(ratingText, 20, finalY);

                    // Ease delta relative to neutral (5) — moved to next line with label, smaller font
                    const easeDelta = tests.comparativeEase - 5;
                    const deltaText = `${easeDelta > 0 ? ('+' + easeDelta) : easeDelta}`;
                    finalY += 5;
                    doc.setFontSize(9);
                    doc.text(`Ease of Listening Delta: ${deltaText}`, 20, finalY);
                    doc.setFontSize(10);

                    finalY += 6;
                    let easeDesc = "No Difference";
                    if (tests.comparativeEase > 5) easeDesc = "New condition is Easier";
                    if (tests.comparativeEase < 5) easeDesc = "New condition is Harder";
                    doc.setFontSize(9);
                    doc.text(`(${easeDesc})`, 25, finalY);
                    doc.setFontSize(10);
                }

                // Notes
                finalY += 15;
                doc.text("Clinical Notes:", 20, finalY);
                doc.rect(20, finalY + 2, 170, 30);

                // Signature
                finalY += 50;
                doc.line(20, finalY, 80, finalY);
                doc.text("Provider Signature", 20, finalY + 5);

                doc.save(`NU6_Report_${patientName.replace(/\s/g, '_')}_${testDate}.pdf`);
            };

            const getEffortColor = (val) => { if (val <= 4) return 'text-emerald-600'; if (val >= 6) return 'text-red-600'; return 'text-blue-600'; };

            if (!dbReady) return <div className="min-h-screen flex items-center justify-center text-slate-500"><Loader className="w-8 h-8 mr-2"/> Initializing secure storage...</div>;
            if (isLocked) return <LoginModal isSetup={hasPassword} onLogin={() => setIsLocked(false)} />;

            // Determine if we show comparative ease scale
            // Logic: Show if Word Diff is NOT Significant AND (Phoneme Diff is NOT Significant OR not in phoneme mode)
            const showComparativeEase = !isWordDiffSig && !(tests.A.scoringMode === 'phoneme' && isPhonemeDiffSig);

            return (
                <div className="min-h-screen bg-slate-100 text-slate-900 p-4 md:p-8 print:p-0 print:bg-white">
                    <ListeningEffortScaleModal isOpen={showScaleModal} onClose={() => setShowScaleModal(false)} />
                    <CriticalDifferenceModal isOpen={showChartModal} onClose={() => setShowChartModal(false)} confidenceLevel={confidenceLevel} />
                    <PhonemeDisclaimerModal isOpen={showPhonemeModal} onClose={() => setShowPhonemeModal(false)} />
                    <LoadTestModal isOpen={showLoadModal} onClose={() => setShowLoadModal(false)} onLoad={handleLoadTest} />
                    <SettingsModal isOpen={showSettingsModal} onClose={() => setShowSettingsModal(false)} initialSettings={clinicSettings} onSave={handleSaveSettings} />
                    <ComparativeEaseScaleModal isOpen={showComparativeScaleModal} onClose={() => setShowComparativeScaleModal(false)} />
                    <ImportPreviewModal isOpen={showImportPreviewModal} onClose={() => setShowImportPreviewModal(false)} fileName={importPreviewFileName} records={importPreviewRecords} invalidCount={importPreviewInvalidCount} onImportOverwrite={() => importRecords('overwrite')} onImportAppend={() => importRecords('append')} onImportSkip={() => importRecords('skip')} onImportMerge={() => importRecords('merge')} onImportUseSelected={() => importRecords(importModePick)} defaultMode={importModePick} />
                    <RecoveryModal isOpen={showRecoveryModal} data={recoveryData} onRestore={handleRestoreRecovery} onDiscard={handleDiscardRecovery} />

                    {/* Export Options Modal */}
                    {showExportModal && (
                        <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
                            <div className="bg-white rounded-xl shadow-lg w-full max-w-md p-6 relative">
                                <button onClick={() => setShowExportModal(false)} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><X className="w-5 h-5" /></button>
                                <h3 className="text-lg font-bold text-slate-800 mb-3">Export Database</h3>
                                <p className="text-sm text-slate-600 mb-4">Choose export format:</p>
                                <div className="space-y-3">
                                    <button onClick={handleExportEncrypted} className="w-full px-4 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-left transition">
                                        <div className="font-semibold">🔒 Encrypted Export (with PHI)</div>
                                        <div className="text-xs opacity-90 mt-1">AES-256 encrypted, password protected, includes all patient data</div>
                                    </button>
                                    <button onClick={handleExportDeidentified} className="w-full px-4 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg text-left transition">
                                        <div className="font-semibold">🔓 De-identified Export (PHI removed)</div>
                                        <div className="text-xs opacity-90 mt-1">Unencrypted, removes patient name & DOB, age 90+ grouped</div>
                                    </button>
                                </div>
                                <button onClick={() => setShowExportModal(false)} className="w-full mt-3 px-4 py-2 bg-slate-100 rounded text-slate-700">Cancel</button>
                            </div>
                        </div>
                    )}

                    {/* Encrypted Import Password Modal */}
                    {showEncryptedImportModal && (
                        <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
                            <div className="bg-white rounded-xl shadow-lg w-full max-w-md p-6 relative">
                                <button onClick={() => { setShowEncryptedImportModal(false); setEncryptedImportPassword(''); setEncryptedImportFile(null); }} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><X className="w-5 h-5" /></button>
                                <h3 className="text-lg font-bold text-slate-800 mb-3">🔒 Encrypted Import</h3>
                                <p className="text-sm text-slate-600 mb-4">This file is encrypted. Enter the password used during export:</p>
                                <input 
                                    type="password" 
                                    value={encryptedImportPassword} 
                                    onChange={(e) => setEncryptedImportPassword(e.target.value)}
                                    onKeyPress={(e) => { if (e.key === 'Enter') handleDecryptAndImport(); }}
                                    placeholder="Enter password" 
                                    className="w-full px-3 py-2 border border-slate-300 rounded mb-4" 
                                    autoFocus 
                                />
                                <div className="flex gap-2">
                                    <button onClick={handleDecryptAndImport} className="flex-1 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Decrypt & Import</button>
                                    <button onClick={() => { setShowEncryptedImportModal(false); setEncryptedImportPassword(''); setEncryptedImportFile(null); }} className="flex-1 px-4 py-2 bg-slate-100 rounded">Cancel</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Delete DB Warning Modal */}
                    {showDeleteDbModal && (
                        <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
                            <div className="bg-white rounded-xl shadow-lg w-full max-w-md p-6 relative">
                                <button onClick={() => { setShowDeleteDbModal(false); setDeleteDbConfirmText(''); }} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><X className="w-5 h-5" /></button>
                                <h3 className="text-lg font-bold text-slate-800 mb-2">Danger: Delete Local Database</h3>
                                <p className="text-sm text-slate-600 mb-4">This action will permanently delete <strong>all patient records</strong> from the local database. Clinic settings will be preserved. This cannot be undone.</p>
                                <div className="mb-4">
                                    <label className="block text-xs font-medium text-slate-500 mb-1">Type <span className="font-mono">DELETE</span> to confirm</label>
                                    <input type="text" value={deleteDbConfirmText} onChange={(e) => setDeleteDbConfirmText(e.target.value)} placeholder="Type DELETE to confirm" className="w-full px-3 py-2 border border-slate-300 rounded" autoFocus />
                                </div>
                                <div className="flex justify-end gap-2">
                                    <button onClick={() => { setShowDeleteDbModal(false); setDeleteDbConfirmText(''); }} className="px-4 py-2 bg-white border rounded">Cancel</button>
                                    <button onClick={async () => { if (deleteDbConfirmText === 'DELETE') { setShowDeleteDbModal(false); setDeleteDbConfirmText(''); try { await window.SecureDB.deleteAllTests(); alert('Database cleared. Clinic settings preserved.'); resetForm(); } catch (e) { console.error(e); alert('Failed to delete database.'); } } else { alert('Please type DELETE to confirm.'); } }} className="px-4 py-2 bg-red-600 text-white rounded">Delete Database</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Import Source Modal: choose simulated DB or upload file */}
                    {showImportSourceModal && (
                        <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
                            <div className="bg-white rounded-xl shadow-lg w-full max-w-sm p-6 relative">
                                <button onClick={() => setShowImportSourceModal(false)} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><X className="w-5 h-5" /></button>
                                <h3 className="text-lg font-bold text-slate-800 mb-3">Import Source</h3>
                                <p className="text-sm text-slate-600 mb-4">Choose a source to import records from.</p>
                                <div className="space-y-3">
                                    <button onClick={handleUseSimulatedDB} className="w-full px-4 py-2 bg-slate-100 rounded text-slate-800">Use Simulated DB (100 records, longitudinal)</button>
                                    <button onClick={handleUseFileUpload} className="w-full px-4 py-2 bg-white border rounded text-slate-800">Upload JSON File</button>
                                </div>
                                <div className="mt-4 text-xs text-slate-500">Tip: choose <strong>Skip duplicates</strong> mode if you are re-importing the same exported file to avoid duplicates, or <strong>Merge duplicates</strong> to combine updated IDs.</div>
                            </div>
                        </div>
                    )}

                    <div className="max-w-5xl mx-auto space-y-6">
                        {/* Header Controls */}
                        <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6 print:hidden">
                            <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6">
                                <div>
                                    <h1 className="text-2xl font-bold text-slate-800 flex items-center gap-2">
                                        <Calculator className="w-6 h-6 text-blue-600" />
                                        Hearing Aid Demo Word and Phoneme Scorer
                                    </h1>
                                    <p className="text-slate-500 text-sm">Comparison Mode & Multi-list Support</p>
                                </div>
                                <div className="flex flex-wrap gap-2 justify-end">
                                    <button onClick={() => setShowSettingsModal(true)} className="flex items-center gap-2 px-3 py-2 bg-slate-100 text-slate-600 rounded-lg hover:bg-slate-200 transition text-sm font-medium"><SettingsIcon className="w-4 h-4"/></button>
                                    {/* Delete DB (moved up) */}
                                    <button onClick={() => setShowDeleteDbModal(true)} className={`flex items-center gap-2 px-4 py-2 rounded-lg transition text-sm font-medium bg-red-50 text-red-700 hover:bg-red-200`}><Trash2 className="w-4 h-4" /> Delete DB</button>
                                    <button onClick={handleExportDB} className="flex items-center gap-2 px-4 py-2 bg-slate-200 text-slate-700 rounded-lg hover:bg-slate-300 transition text-sm font-medium"><Download className="w-4 h-4" /> Export DB</button>
                                    <div className="flex items-center gap-2">
                                        <button onClick={handleImportDB} className="flex items-center gap-2 px-4 py-2 bg-slate-100 text-slate-700 rounded-lg hover:bg-slate-200 transition text-sm font-medium"><FileUp className="w-4 h-4" /> Import DB (JSON)</button>
                                    </div>
                                    <input type="file" accept=".json,application/json" ref={fileInputRef} style={{display:'none'}} onChange={handleImportFile} />
                                    <button onClick={() => setShowLoadModal(true)} className="flex items-center gap-2 px-4 py-2 bg-slate-200 text-slate-700 rounded-lg hover:bg-slate-300 transition text-sm font-medium"><Database className="w-4 h-4" /> Load Patient</button>

                                    <button onClick={handleExportPDF} className="flex items-center gap-2 px-4 py-2 bg-blue-100 text-blue-700 rounded-lg hover:bg-blue-200 transition text-sm font-medium"><FileText className="w-4 h-4" /> PDF Report</button>
                                    <div className="flex flex-col gap-1">
                                        <button onClick={handleSave} className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition text-sm font-medium"><Save className="w-4 h-4" /> Save (Local)</button>
                                        {lastSaved && (
                                            <div className="text-[10px] text-slate-400 text-center">
                                                Last saved: {lastSaved.toLocaleTimeString()}
                                            </div>
                                        )}
                                    </div>
                                    {currentTestId && (
                                        <button onClick={handleDeleteCurrentRecord} className="flex items-center gap-2 px-4 py-2 bg-red-100 text-red-700 rounded-lg hover:bg-red-200 transition text-sm font-medium"><Trash2 className="w-4 h-4" /> Delete</button>
                                    )}

                                    {/* New Test - make green */}
                                    <button onClick={clearAllData} className={`flex items-center gap-2 px-4 py-2 rounded-lg transition text-sm font-medium ${clearConfirm ? 'bg-green-600 text-white hover:bg-green-700' : 'bg-green-100 text-green-700 hover:bg-green-200'}`}><RotateCcw className="w-4 h-4" /> {clearConfirm ? "Confirm?" : "New Test"}</button>
                                </div>
                            </div>

                            {/* Patient Info */}
                            <div className="bg-slate-50 p-6 rounded-xl border border-slate-200 mb-6">
                                <h3 className="text-sm font-bold text-slate-400 uppercase tracking-wider mb-4">Patient Information</h3>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                                    <div><label className="block text-xs font-medium text-slate-500 mb-1">First Name</label><input type="text" value={firstName} onChange={(e) => { setFirstName(e.target.value); setHasUnsavedChanges(true); }} className="w-full px-3 py-2 rounded-lg border border-slate-300 text-sm" placeholder="First name..." /></div>
                                    <div><label className="block text-xs font-medium text-slate-500 mb-1">Last Name</label><input type="text" value={lastName} onChange={(e) => { setLastName(e.target.value); setHasUnsavedChanges(true); }} className="w-full px-3 py-2 rounded-lg border border-slate-300 text-sm" placeholder="Last name..." /></div>
                                    <div><label className="block text-xs font-medium text-slate-500 mb-1">ID</label><input type="text" value={cNumber} onChange={(e) => { setCNumber(e.target.value); setHasUnsavedChanges(true); }} className="w-full px-3 py-2 rounded-lg border border-slate-300 text-sm" placeholder="Patient ID" /></div>
                                    <div><label className="block text-xs font-medium text-slate-500 mb-1">Date of Birth</label><input type="date" value={dateOfBirth} onChange={(e) => { setDateOfBirth(e.target.value); setHasUnsavedChanges(true); }} className="w-full px-3 py-2 rounded-lg border border-slate-300 text-sm" /></div>
                                    <div><label className="block text-xs font-medium text-slate-500 mb-1">Age</label><div className="w-full px-3 py-2 rounded-lg border border-slate-200 text-sm bg-white h-[42px] flex items-center">{ageYears !== null && ageYears !== undefined ? `${ageYears} years` : '—'}</div></div>
                                    <div><label className="block text-xs font-medium text-slate-500 mb-1">Test Date</label><input type="date" value={testDate} onChange={(e) => { setTestDate(e.target.value); setHasUnsavedChanges(true); }} className="w-full px-3 py-2 rounded-lg border border-slate-300 text-sm" /></div>
                                </div>
                                <div className="mt-3 text-xs text-slate-500 flex items-center gap-2"><span className="inline-flex px-2 py-1 rounded bg-blue-100 text-blue-700 text-[11px] font-semibold">Comparison Mode Active</span><span>Age auto-calculates using DOB and Test Date.</span></div>
                            </div>

                            {/* Tabs */}
                            <div className="flex space-x-1 bg-slate-100 p-1 rounded-lg w-fit">
                                <button onClick={() => setActiveTab('scoring')} className={`px-4 py-2 text-sm font-medium rounded-md tab-btn flex items-center gap-2 ${activeTab === 'scoring' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-600 hover:text-slate-900'}`}><CheckCircle2 className="w-4 h-4" /> Scoring Entry</button>
                                <button onClick={() => setActiveTab('comparison')} className={`px-4 py-2 text-sm font-medium rounded-md tab-btn flex items-center gap-2 ${activeTab === 'comparison' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-600 hover:text-slate-900'}`}><BarChart3 className="w-4 h-4" /> Comparison Results</button>
                                <button onClick={() => setActiveTab('history')} className={`px-4 py-2 text-sm font-medium rounded-md tab-btn flex items-center gap-2 ${activeTab === 'history' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-600 hover:text-slate-900'}`}><HistoryIcon className="w-4 h-4" /> Longitudinal History</button>
                            </div>
                        </div>

                        {/* Content */}
                        {activeTab === 'scoring' && (
                            <div className="space-y-6">
                                <div className="grid grid-cols-2 gap-4 print:hidden">
                                    {['A', 'B'].map(id => {
                                        const t = tests[id]; const s = id === 'A' ? statsA : statsB; const isActive = activeTestId === id;
                                        return (
                                            <button key={id} onClick={() => setActiveTestId(id)} className={`relative p-4 rounded-xl border-2 text-left transition-all ${isActive ? 'border-blue-500 bg-blue-50/50' : 'border-slate-200 bg-white hover:border-slate-300'}`}>
                                                <div className="flex justify-between items-start mb-2"><span className={`px-2 py-0.5 rounded text-xs font-bold ${isActive ? 'bg-blue-600 text-white' : 'bg-slate-200 text-slate-600'}`}>TEST {id}</span>{isActive && <span className="flex h-3 w-3 relative"><span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-blue-400 opacity-75"></span><span className="relative inline-flex rounded-full h-3 w-3 bg-blue-500"></span></span>}</div>
                                                <div className="text-sm font-semibold text-slate-800">{t.condition}</div>
                                                <div className="text-xs text-slate-500 mb-2">{t.listId} {t.section}</div>
                                                <div className="flex gap-3 text-sm"><span className="font-bold text-slate-700">W: {s.wordPercent}%</span>{t.scoringMode === 'phoneme' && <span className="font-bold text-slate-700">P: {s.phonemePercent}%</span>}</div>
                                            </button>
                                        );
                                    })}
                                </div>

                                <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6 print:hidden">
                                    <div className="grid grid-cols-1 lg:grid-cols-12 gap-6">
                                        <div className="lg:col-span-5 space-y-6">
                                            <div><label className="block text-xs font-medium text-slate-500 mb-2">Condition</label><div className="flex rounded-lg overflow-hidden border border-slate-200 mb-3">{(activeTestId === 'A' ? ['Unaided', 'Current Tech'] : ['Current Tech', 'New Tech']).map(c => (<button key={c} onClick={() => updateActiveTest('condition', c)} className={`flex-1 py-2 text-sm font-medium transition ${activeTest.condition === c ? 'bg-indigo-600 text-white' : 'bg-slate-50 hover:bg-slate-100 text-slate-600'}`}>{c}</button>))}</div>{(activeTest.condition === 'Current Tech' || activeTest.condition === 'New Tech') && (<div><input type="text" value={activeTest.deviceModel || ''} onChange={(e) => updateActiveTest('deviceModel', e.target.value)} className="w-full px-3 py-2 rounded-lg border border-slate-300 text-sm" placeholder="Enter Make/Model..." /></div>)}</div>
                                            <div><label className="block text-xs font-medium text-slate-500 mb-2">Scoring Mode</label><div className="flex rounded-lg overflow-hidden border border-slate-200"><button onClick={() => updateActiveTest('scoringMode', 'phoneme')} className={`flex-1 py-2 text-xs font-bold flex items-center justify-center gap-1 transition ${activeTest.scoringMode === 'phoneme' ? 'bg-slate-700 text-white' : 'bg-slate-50 text-slate-600 hover:bg-slate-100'}`}><ListChecks className="w-3 h-3" /> Phoneme</button><button onClick={() => updateActiveTest('scoringMode', 'word')} className={`flex-1 py-2 text-xs font-bold flex items-center justify-center gap-1 transition ${activeTest.scoringMode === 'word' ? 'bg-slate-700 text-white' : 'bg-slate-50 text-slate-600 hover:bg-slate-100'}`}><WholeWord className="w-3 h-3" /> Word</button></div></div>
                                        </div>
                                        <div className="lg:col-span-7 grid grid-cols-2 gap-4">
                                            <div><label className="block text-xs font-medium text-slate-500 mb-1">Word List</label><select value={activeTest.listId} onChange={(e) => updateActiveTest('listId', e.target.value)} className="w-full px-3 py-2 rounded-lg border border-slate-300 text-sm"><option value="1A">NU-6 List 1A</option><option value="2A">NU-6 List 2A</option><option value="3A">NU-6 List 3A</option><option value="4A">NU-6 List 4A</option><option value="HF1">HF Word List Form 1</option><option value="HF2">HF Word List Form 2</option></select></div>
                                            <div><label className="block text-xs font-medium text-slate-500 mb-1">Section</label><select value={activeTest.section} onChange={(e) => updateActiveTest('section', e.target.value)} className="w-full px-3 py-2 rounded-lg border border-slate-300 text-sm">{getSectionOptions(activeTestId).map(opt => (<option key={opt.val} value={opt.val}>{opt.label}</option>))}</select></div>
                                            <div><label className="block text-xs font-medium text-slate-500 mb-1">Level (e.g., MLV-avg or 65 dBC)</label><input type="text" value={activeTest.level} onChange={(e) => updateActiveTest('level', e.target.value)} className="w-full px-3 py-2 rounded-lg border border-slate-300 text-sm" /></div>
                                            <div><label className="block text-xs font-medium text-slate-500 mb-1">Noise (e.g., +10 dB SNR or 55 dBC)</label><input type="text" value={activeTest.snr} onChange={(e) => updateActiveTest('snr', e.target.value)} className="w-full px-3 py-2 rounded-lg border border-slate-300 text-sm" /></div>
                                        </div>
                                    </div>
                                </div>
                                <div className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden print:shadow-none print:border-2 print:border-black">
                                    <div className="bg-slate-50 px-4 py-3 border-b border-slate-200 flex justify-between items-center print:bg-slate-200">
                                        <div className="font-bold text-slate-700 flex items-center gap-2">Scoring: Test {activeTestId} <span className="font-normal text-slate-500 mx-1">|</span> {activeTest.listId} {activeTest.section}{activeTest.limitTo10 && <span className="ml-2 px-2 py-0.5 bg-orange-100 text-orange-700 text-xs rounded-full border border-orange-200 flex items-center gap-1"><AlertCircle className="w-3 h-3"/> Limited to 10 Words</span>}</div>
                                        <div className="flex gap-2 print:hidden"><button onClick={() => markAll(true)} className="text-xs px-2 py-1 bg-emerald-100 text-emerald-700 rounded hover:bg-emerald-200 font-medium">Mark All</button></div>
                                    </div>
                                    <table className="w-full text-left text-sm">
                                        <thead className="bg-slate-50 border-b border-slate-200 text-xs uppercase text-slate-500 print:hidden"><tr><th className="px-4 py-2 w-10">#</th><th className="px-4 py-2">Word</th>{activeTest.scoringMode === 'phoneme' && (<React.Fragment><th className="px-2 py-2 text-center">I</th><th className="px-2 py-2 text-center">M</th><th className="px-2 py-2 text-center">F</th></React.Fragment>)}<th className="px-4 py-2 text-center">{activeTest.scoringMode === 'phoneme' ? 'Word' : 'Result'}</th></tr></thead>
                                        <tbody className="divide-y divide-slate-100">
                                            {activeStats.visibleWords.map((word) => {
                                                const listId = activeTest.listId; const phonemeScores = word.p.map((p, idx) => { if (p === '-') return null; return activeTest.scores[`${listId}_${word.i}_${idx}`]; }).filter(val => val !== null); const isWordCorrect = phonemeScores.every(s => s === true); const isWordFullyIncorrect = phonemeScores.every(s => s === false);
                                                return (
                                                    <tr key={word.i} className="hover:bg-slate-50"><td className="px-4 py-2 text-slate-400 font-mono text-xs">{word.i}</td><td className="px-4 py-2 font-bold text-slate-800">{word.w}</td>
                                                        {activeTest.scoringMode === 'phoneme' ? (<React.Fragment>{word.p.map((phoneme, pIndex) => { const isCorrect = !!activeTest.scores[`${listId}_${word.i}_${pIndex}`]; const isPlaceholder = phoneme === '-'; return (<td key={pIndex} className="px-1 py-1 text-center">{!isPlaceholder ? (<button onClick={() => togglePhoneme(word.i, pIndex)} className={`w-10 h-8 rounded flex items-center justify-center font-medium text-base border transition-colors ${isCorrect ? 'bg-emerald-50 border-emerald-200 text-emerald-700 hover:bg-emerald-100 print:border-none print:text-black print:font-bold' : 'bg-white border-slate-200 text-slate-400 hover:border-red-300 hover:text-red-500 hover:bg-red-50'}`}><span className="ipa-text">{phoneme}</span></button>) : <span className="text-slate-300">—</span>}</td>); })}<td className="px-4 py-2 text-center print:hidden"><div className="flex items-center justify-center gap-2"><button onClick={() => toggleWordCorrect(word.i)} title={isWordCorrect ? "Clear Word" : "Mark Whole Word Correct"} className={`w-8 h-8 rounded-full border flex items-center justify-center transition-colors ${isWordCorrect ? 'bg-emerald-100 border-emerald-300 text-emerald-700' : 'bg-slate-50 border-slate-200 text-slate-400 hover:bg-emerald-50 hover:text-emerald-500 hover:border-emerald-200'}`}><Check className="w-4 h-4" /></button></div></td></React.Fragment>) : (<td className="px-4 py-2 text-center"><div className="flex gap-2 justify-center"><button onClick={() => setWordScore(word.i, true)} className={`flex-1 max-w-[80px] py-1.5 rounded-md font-bold text-xs border transition-colors flex items-center justify-center gap-1 ${isWordCorrect ? 'bg-emerald-600 text-white border-emerald-700 shadow-sm' : 'bg-white border-slate-200 text-slate-400 hover:bg-emerald-50 hover:text-emerald-600'}`}><Check className="w-3 h-3" /> Correct</button><button onClick={() => setWordScore(word.i, false)} className={`flex-1 max-w-[80px] py-1.5 rounded-md font-bold text-xs border transition-colors flex items-center justify-center gap-1 ${isWordFullyIncorrect ? 'bg-red-600 text-white border-red-700 shadow-sm' : 'bg-white border-slate-200 text-slate-400 hover:bg-red-50 hover:text-red-600'}`}><X className="w-3 h-3" /> Incorrect</button></div></td>)}
                                                    </tr>
                                                );
                                            })}
                                        </tbody>
                                    </table>
                                </div>
                                {activeTest.scoringMode === 'phoneme' && !activeTest.section.includes('_10') && (<DiagnosticsPanel stats={activeStats} scores={activeTest.scores} listId={activeTest.listId} />)}
                            </div>
                        )}

                        {activeTab === 'comparison' && (
                            <div className="space-y-6">
                                <div className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden print:shadow-none print:border-2 print:border-black">
                                    <div className="bg-slate-800 text-white px-6 py-4 flex items-center justify-between print:bg-black print:text-white">
                                        <h2 className="text-lg font-bold flex items-center gap-2"><BarChart3 className="w-5 h-5" /> Score Comparison</h2>
                                        <div className="text-right"><div className="text-xs opacity-75 font-mono">{testDate} • {patientName} • #{cNumber}</div><div className="hidden">Thornton & Raffin (1978) Model</div></div>
                                    </div>
                                    <div className="p-6">
                                        <div className="flex justify-end mb-4 print:hidden"><div className="bg-slate-100 p-1 rounded-lg flex items-center gap-2 text-sm"><span className="px-2 text-xs font-semibold text-slate-500 uppercase">Critical Difference Level</span><button onClick={() => setConfidenceLevel(95)} className={`px-3 py-1 rounded-md transition ${confidenceLevel === 95 ? 'bg-white shadow text-blue-700 font-bold' : 'text-slate-600 hover:bg-slate-200'}`}>95%</button><button onClick={() => setConfidenceLevel(80)} className={`px-3 py-1 rounded-md transition ${confidenceLevel === 80 ? 'bg-white shadow text-blue-700 font-bold' : 'text-slate-600 hover:bg-slate-200'}`}>80%</button><button onClick={() => setShowChartModal(true)} className="px-3 py-1 bg-white hover:bg-slate-200 text-slate-600 rounded-md transition border border-slate-200 flex items-center gap-1"><TrendingUp className="w-3 h-3" /> View Tables</button></div></div>
                                        <div className="grid grid-cols-3 gap-8 mb-8">
                                            <div className="bg-slate-50 rounded-lg p-4 border border-slate-200 print:bg-white print:border-black"><div className="text-xs font-bold text-slate-500 uppercase mb-1">Test A (Baseline)</div><div className="text-lg font-bold text-slate-900 mb-2">{tests.A.condition}</div><div className="text-sm text-slate-600 mb-4 space-y-1"><div>List: {tests.A.listId}</div><div>Level: {tests.A.level || '--'}</div><div>Noise: {tests.A.snr || '--'}</div></div><div className="space-y-2 border-t border-slate-200 pt-3"><div className="flex justify-between items-center"><span className="text-sm text-slate-600">Word Score</span><span className="text-xl font-bold text-blue-600">{statsA.wordPercent}%</span></div>{tests.A.scoringMode === 'phoneme' && (<div className="flex justify-between items-center"><span className="text-sm text-slate-600">Phoneme Score</span><span className="text-lg font-semibold text-slate-700">{statsA.phonemePercent}%</span></div>)}</div></div>

                                            <div className="flex flex-col items-center justify-center text-center">
                                                {/* Word recognition difference - label above, styled like Ease label */}
                                                <div className="text-sm font-bold text-slate-500">Word Recognition Difference</div>
                                                <div className={`text-3xl font-bold mb-1 ${statsB.wordPercent - statsA.wordPercent >= 0 ? 'text-emerald-600' : 'text-red-600'}`}>{statsB.wordPercent - statsA.wordPercent > 0 ? '+' : ''}{statsB.wordPercent - statsA.wordPercent}%</div>

                                                {(tests.A.scoringMode === 'phoneme' && tests.B.scoringMode === 'phoneme') && (
                                                    <React.Fragment>
                                                        {/* Phoneme recognition difference - label above, styled like Ease label */}
                                                        <div className="text-sm font-bold text-slate-500 mt-4">Phoneme Recognition Difference</div>
                                                        <div className={`text-3xl font-bold mt-1 ${statsB.phonemePercent - statsA.phonemePercent >= 0 ? 'text-emerald-600' : 'text-red-600'}`}>{statsB.phonemePercent - statsA.phonemePercent > 0 ? '+' : ''}{statsB.phonemePercent - statsA.phonemePercent}%</div>
                                                    </React.Fragment>
                                                )}

                                                {showComparativeEase && (
                                                    <div className="mt-2 text-center">
                                                        <div className="text-sm font-bold text-slate-500">Ease of Listening Delta</div>
                                                        <div className={`text-3xl font-bold mt-1 ${tests.comparativeEase - 5 >= 2 ? 'text-emerald-600' : tests.comparativeEase - 5 <= -2 ? 'text-red-600' : 'text-slate-600'}`} aria-live="polite">{(tests.comparativeEase - 5) >= 0 ? '+' : ''}{tests.comparativeEase - 5}</div>
                                                    </div>
                                                )}
                                            </div>

                                            <div className="bg-slate-50 rounded-lg p-4 border border-slate-200 print:bg-white print:border-black"><div className="text-xs font-bold text-slate-500 uppercase mb-1">Test B (Comparison)</div><div className="text-lg font-bold text-slate-900 mb-2">{tests.B.condition}</div><div className="text-sm text-slate-600 mb-4 space-y-1"><div>List: {tests.B.listId}</div><div>Level: {tests.B.level || '--'}</div><div>Noise: {tests.B.snr || '--'}</div></div><div className="space-y-2 border-t border-slate-200 pt-3"><div className="flex justify-between items-center"><span className="text-sm text-slate-600">Word Score</span><span className="text-xl font-bold text-blue-600">{statsB.wordPercent}%</span></div>{tests.B.scoringMode === 'phoneme' && (<div className="flex justify-between items-center"><span className="text-sm text-slate-600">Phoneme Score</span><span className="text-lg font-semibold text-slate-700">{statsB.phonemePercent}%</span></div>)}</div></div>
                                        </div>

                                        {/* Comparative Ease Slider */}
                                        {showComparativeEase && (
                                            <div className="mb-6 p-4 bg-slate-50 rounded-lg border border-slate-200">
                                                <div className="flex justify-between items-center mb-2">
                                                    <div className="flex items-center gap-2">
                                                        <label className="text-sm font-bold text-slate-700">Comparative Ease of Listening</label>
                                                        <button onClick={() => setShowComparativeScaleModal(true)} className="text-[10px] text-blue-600 hover:underline flex items-center gap-1">
                                                            <HelpCircle className="w-3 h-3" /> View Scale
                                                        </button>
                                                    </div>
                                                    <span className="text-xs text-slate-500 italic">Rate how much easier/harder Condition B is compared to A</span>
                                                </div>
                                                <div className="flex items-center gap-3">
                                                    <span className="text-xs font-bold text-slate-500 uppercase">Harder</span>
                                                    <div className="flex-1 relative">
                                                        <input
                                                            type="range"
                                                            min="0"
                                                            max="10"
                                                            value={tests.comparativeEase}
                                                            onChange={(e) => updateComparativeEase(parseInt(e.target.value))}
                                                            className="w-full h-2 bg-gradient-to-r from-red-300 via-slate-300 to-emerald-300 rounded-lg appearance-none cursor-pointer"
                                                        />
                                                        <div className="flex justify-between text-[10px] text-slate-400 mt-1 px-1">
                                                            <span>0</span>
                                                            <span>5 (No Diff)</span>
                                                            <span>10</span>
                                                        </div>
                                                    </div>
                                                    <span className="text-xs font-bold text-slate-500 uppercase">Easier</span>
                                                    <span className={`font-bold text-lg w-8 text-center ${tests.comparativeEase > 5 ? 'text-emerald-600' : tests.comparativeEase < 5 ? 'text-red-600' : 'text-slate-600'}`}>{tests.comparativeEase}</span>
                                                </div>
                                            </div>
                                        )}

                                        <div className="border border-slate-200 rounded-lg overflow-hidden mb-6"><table className="w-full text-sm"><thead className="bg-slate-100 text-slate-600 font-semibold border-b border-slate-200"><tr><th className="px-4 py-2 text-left">Metric (N)</th><th className="px-4 py-2 text-center w-24">Test A</th><th className="px-4 py-2 text-center w-32 bg-slate-50">Critical Range <span className="text-[10px] text-slate-400 block font-normal">({confidenceLevel}%)</span></th><th className="px-4 py-2 text-center w-24">Test B</th><th className="px-4 py-2 text-center w-32">Significant?</th></tr></thead><tbody className="divide-y divide-slate-100"><tr><td className="px-4 py-3 font-medium text-slate-800">Word Score <span className="block text-xs text-slate-400 font-normal">N = {statsA.totalWords}</span></td><td className="px-4 py-3 text-center text-slate-700 font-bold">{statsA.wordPercent}%</td><td className="px-4 py-3 text-center text-slate-500 bg-slate-50 text-xs font-mono">{wordCriticalLimits.lower}% - {wordCriticalLimits.upper}%</td><td className="px-4 py-3 text-center text-slate-700 font-bold">{statsB.wordPercent}%</td><td className="px-4 py-3 text-center">{isWordDiffSig ? <span className="inline-flex items-center gap-1 text-emerald-600 font-bold bg-emerald-50 px-2 py-1 rounded text-xs"><Check className="w-3 h-3" /> Yes</span> : <span className="inline-flex items-center gap-1 text-red-600 font-bold bg-red-50 px-2 py-1 rounded text-xs"><X className="w-3 h-3" /> No</span>}</td></tr>{(tests.A.scoringMode === 'phoneme' && tests.B.scoringMode === 'phoneme') && (<tr><td className="px-4 py-3 font-medium text-slate-800">Phoneme Score <span className="block text-xs text-slate-400 font-normal">N = {statsA.totalPhonemes}</span></td><td className="px-4 py-3 text-center text-slate-700 font-bold">{statsA.phonemePercent}%</td><td className="px-4 py-3 text-center text-slate-500 bg-slate-50 text-xs font-mono">{Number(phonemeCriticalLimits.lower).toFixed(1)}% - {Number(phonemeCriticalLimits.upper).toFixed(1)}%</td><td className="px-4 py-3 text-center text-slate-700 font-bold">{statsB.phonemePercent}%</td><td className="px-4 py-3 text-center">{isPhonemeDiffSig ? <span className="inline-flex items-center gap-1 text-emerald-600 font-bold bg-emerald-50 px-2 py-1 rounded text-xs"><Check className="w-3 h-3" /> Yes</span> : <span className="inline-flex items-center gap-1 text-red-600 font-bold bg-red-50 px-2 py-1 rounded text-xs"><X className="w-3 h-3" /> No</span>}</td></tr>)}</tbody></table></div>

                                        {/* Visual Critical Range Comparison */}
                                        <div className="bg-slate-50 border border-slate-200 rounded-lg p-6 mb-6">
                                            <h4 className="text-sm font-bold text-slate-700 mb-4">Visual Critical Range Comparison</h4>
                                            
                                            {/* Word Score Visualization */}
                                            <div className="mb-6">
                                                <div className="text-xs font-semibold text-slate-600 mb-2">Word Score Range</div>
                                                <div className="relative h-20 bg-white border border-slate-300 rounded-lg px-3">
                                                    {/* Scale markers */}
                                                    <div className="absolute inset-x-0 top-1 flex justify-between px-3 text-[10px] text-slate-400">
                                                        <span>0%</span>
                                                        <span>25%</span>
                                                        <span>50%</span>
                                                        <span>75%</span>
                                                        <span>100%</span>
                                                    </div>
                                                    
                                                    {/* Critical range bar */}
                                                    <div 
                                                        className="absolute top-9 h-6 bg-blue-100 border-l-2 border-r-2 border-blue-400"
                                                        style={{
                                                            left: `${wordCriticalLimits.lower}%`,
                                                            width: `${wordCriticalLimits.upper - wordCriticalLimits.lower}%`
                                                        }}
                                                    >
                                                    </div>
                                                    
                                                    {/* Test A marker */}
                                                    <div 
                                                        className="absolute top-8 w-1.5 h-8 bg-purple-600 z-10 shadow-lg"
                                                        style={{ left: `calc(${statsA.wordPercent}% - 3px)` }}
                                                        title={`Test A: ${statsA.wordPercent}%`}
                                                    >
                                                        <div className="absolute top-9 left-1/2 -translate-x-1/2 whitespace-nowrap text-[10px] font-bold text-purple-600">
                                                            A: {statsA.wordPercent}%
                                                        </div>
                                                    </div>
                                                    
                                                    {/* Test B marker */}
                                                    <div 
                                                        className={`absolute top-8 w-1.5 h-8 z-10 shadow-lg ${isWordDiffSig ? 'bg-emerald-600' : 'bg-orange-500'}`}
                                                        style={{ left: `calc(${statsB.wordPercent}% - 3px)` }}
                                                        title={`Test B: ${statsB.wordPercent}%`}
                                                    >
                                                        <div className={`absolute top-9 left-1/2 -translate-x-1/2 whitespace-nowrap text-[10px] font-bold ${isWordDiffSig ? 'text-emerald-600' : 'text-orange-600'}`}>
                                                            B: {statsB.wordPercent}%
                                                        </div>
                                                    </div>
                                                </div>
                                                <div className="mt-2 text-xs text-slate-500 flex items-center gap-3">
                                                    <span className="flex items-center gap-1"><span className="w-3 h-3 bg-purple-600 rounded-sm"></span> Test A</span>
                                                    <span className="flex items-center gap-1"><span className={`w-3 h-3 rounded-sm ${isWordDiffSig ? 'bg-emerald-600' : 'bg-orange-500'}`}></span> Test B {isWordDiffSig ? '(Significant)' : '(Not Significant)'}</span>
                                                    <span className="flex items-center gap-1"><span className="w-3 h-3 bg-blue-100 border border-blue-400 rounded-sm"></span> Critical Range ({confidenceLevel}%)</span>
                                                </div>
                                            </div>

                                            {/* Phoneme Score Visualization - only show if both tests use phoneme mode */}
                                            {(tests.A.scoringMode === 'phoneme' && tests.B.scoringMode === 'phoneme') && (
                                                <div>
                                                    <div className="text-xs font-semibold text-slate-600 mb-2">Phoneme Score Range</div>
                                                    <div className="relative h-20 bg-white border border-slate-300 rounded-lg px-3">
                                                        {/* Scale markers */}
                                                        <div className="absolute inset-x-0 top-1 flex justify-between px-3 text-[10px] text-slate-400">
                                                            <span>0%</span>
                                                            <span>25%</span>
                                                            <span>50%</span>
                                                            <span>75%</span>
                                                            <span>100%</span>
                                                        </div>
                                                        
                                                        {/* Critical range bar */}
                                                        <div 
                                                            className="absolute top-9 h-6 bg-indigo-100 border-l-2 border-r-2 border-indigo-400"
                                                            style={{
                                                                left: `${phonemeCriticalLimits.lower}%`,
                                                                width: `${phonemeCriticalLimits.upper - phonemeCriticalLimits.lower}%`
                                                            }}
                                                        >
                                                        </div>
                                                        
                                                        {/* Test A marker */}
                                                        <div 
                                                            className="absolute top-8 w-1.5 h-8 bg-purple-600 z-10 shadow-lg"
                                                            style={{ left: `calc(${statsA.phonemePercent}% - 3px)` }}
                                                            title={`Test A: ${statsA.phonemePercent}%`}
                                                        >
                                                            <div className="absolute top-9 left-1/2 -translate-x-1/2 whitespace-nowrap text-[10px] font-bold text-purple-600">
                                                                A: {statsA.phonemePercent}%
                                                            </div>
                                                        </div>
                                                        
                                                        {/* Test B marker */}
                                                        <div 
                                                            className={`absolute top-8 w-1.5 h-8 z-10 shadow-lg ${isPhonemeDiffSig ? 'bg-emerald-600' : 'bg-orange-500'}`}
                                                            style={{ left: `calc(${statsB.phonemePercent}% - 3px)` }}
                                                            title={`Test B: ${statsB.phonemePercent}%`}
                                                        >
                                                            <div className={`absolute top-9 left-1/2 -translate-x-1/2 whitespace-nowrap text-[10px] font-bold ${isPhonemeDiffSig ? 'text-emerald-600' : 'text-orange-600'}`}>
                                                                B: {statsB.phonemePercent}%
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <div className="mt-2 text-xs text-slate-500 flex items-center gap-3">
                                                        <span className="flex items-center gap-1"><span className="w-3 h-3 bg-purple-600 rounded-sm"></span> Test A</span>
                                                        <span className="flex items-center gap-1"><span className={`w-3 h-3 rounded-sm ${isPhonemeDiffSig ? 'bg-emerald-600' : 'bg-orange-500'}`}></span> Test B {isPhonemeDiffSig ? '(Significant)' : '(Not Significant)'}</span>
                                                        <span className="flex items-center gap-1"><span className="w-3 h-3 bg-indigo-100 border border-indigo-400 rounded-sm"></span> Critical Range ({confidenceLevel}%)</span>
                                                    </div>
                                                </div>
                                            )}
                                        </div>

                                        <div><label className="block text-xs font-bold uppercase text-slate-500 mb-2">Clinical Interpretation / Notes</label><textarea className="w-full border border-slate-300 rounded-lg p-3 text-sm focus:ring-2 focus:ring-blue-500 h-24" placeholder="Enter notes comparing the two conditions..."></textarea></div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {activeTab === 'history' && (
                            <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6 print:shadow-none print:border-2 print:border-black">
                                <HistoryChart cNumber={cNumber} />
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        try {
            root.render(<App />);
            console.log('React app rendered successfully');
            // Check if Tailwind loaded
            setTimeout(() => {
                const testEl = document.createElement('div');
                testEl.className = 'hidden';
                document.body.appendChild(testEl);
                const isHidden = window.getComputedStyle(testEl).display === 'none';
                document.body.removeChild(testEl);
                if (!isHidden) {
                    console.error('Tailwind CSS failed to load! App may appear blank.');
                    alert('Warning: The app styling failed to load. Please check your internet connection and restart the app.');
                }
            }, 1000);
        } catch (error) {
            console.error('Failed to render React app:', error);
            document.body.innerHTML = '<div style="padding: 20px; color: red; font-family: monospace;">Error rendering app: ' + error.message + '</div>';
        }
    </script>
</body>
</html>